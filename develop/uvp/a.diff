只在 . 存在：a.diff
只在 /home/xt/dev/cpp/uv/. 存在：a.txt
只在 /home/xt/dev/cpp/uv/. 存在：build
只在 /home/xt/dev/cpp/uv/. 存在：main.c
diff -ur ./main.cpp /home/xt/dev/cpp/uv/./main.cpp
--- ./main.cpp	2018-12-05 01:23:25.978170470 +0800
+++ /home/xt/dev/cpp/uv/./main.cpp	2018-12-06 01:45:59.585336906 +0800
@@ -10,7 +10,7 @@
 
 // --
 
-void test_idle(const std::unique_ptr<LoopT> &loop) {
+void test_idle(LoopT *loop) {
   int counter = 0;
   IdleT idler(loop);
   idler.start([&idler, &counter]() {
@@ -22,6 +22,13 @@
   });
   idler.data(&counter);
 
+  loop->walk(
+      [](HandleI *h, void *arg) {
+        std::cout << "walk, handle is " << HandleI::typeName(h->type())
+                  << std::endl;
+      },
+      0);
+
   std::cout << "Idling..." << std::endl;
   loop->run(UV_RUN_DEFAULT);
 
@@ -34,7 +41,7 @@
 
 // --
 
-void test_timer(const std::unique_ptr<LoopT> &loop) {
+void test_timer(LoopT *loop) {
   int counter = 0;
   TimerT timer(loop);
   timer.start(
@@ -59,6 +66,13 @@
       1000, 200);
   timer.data(&counter);
 
+  loop->walk(
+      [](HandleI *h, void *arg) {
+        std::cout << "walk, handle is " << HandleI::typeName(h->type())
+                  << ". arg is " << arg << "." << std::endl;
+      },
+      0);
+
   std::cout << "Timer..." << std::endl;
   loop->run(UV_RUN_DEFAULT);
 
@@ -69,17 +83,180 @@
   std::cout << "ldler.type(): " << IdleT::typeName(timer.type()) << std::endl;
 }
 
-int main() {
+void test_tcp_client(LoopT *loop) {}
+
+// --
+
+static char buffer[1024];
+
+static uv_buf_t iov;
+
+uv_fs_t open_req;
+uv_fs_t read_req;
+uv_fs_t write_req;
+
+void on_write(uv_fs_t *req);
+
+void on_read(uv_fs_t *req) {
+  if (req->result < 0) {
+    fprintf(stderr, "Read error: %s\n", uv_strerror(req->result));
+  } else if (req->result == 0) {
+    uv_fs_t close_req;
+    // synchronous
+    uv_fs_close(uv_default_loop(), &close_req, open_req.result, NULL);
+  } else if (req->result > 0) {
+    iov.len = req->result;
+    uv_fs_write(uv_default_loop(), &write_req, 1, &iov, 1, -1, on_write);
+  }
+}
+
+void on_write(uv_fs_t *req) {
+  if (req->result < 0) {
+    fprintf(stderr, "Write error: %s\n", uv_strerror((int)req->result));
+  } else {
+    uv_fs_read(uv_default_loop(), &read_req, open_req.result, &iov, 1, -1,
+               on_read);
+  }
+}
+
+void on_open(uv_fs_t *req) {
+  // The request passed to the callback is the same as the one the call setup
+  // function was passed.
+  assert(req == &open_req);
+  if (req->result >= 0) {
+    iov = uv_buf_init(buffer, sizeof(buffer));
+    uv_fs_read(uv_default_loop(), &read_req, req->result, &iov, 1, -1, on_read);
+  } else {
+    fprintf(stderr, "error opening file: %s\n", uv_strerror((int)req->result));
+  }
+}
+
+void test_cat(LoopT *loop, const char *filename) {
+  uv_fs_open(loop->get(), &open_req, filename, O_RDONLY, 0, on_open);
+  loop->run(UV_RUN_DEFAULT);
+
+  uv_fs_req_cleanup(&open_req);
+  uv_fs_req_cleanup(&read_req);
+  uv_fs_req_cleanup(&write_req);
+}
+
+// --
+
+typedef struct {
+  uv_write_t req;
+  uv_buf_t buf;
+} write_req_t;
+
+uv_loop_t *loop;
+uv_pipe_t stdin_pipe;
+uv_pipe_t stdout_pipe;
+uv_pipe_t file_pipe;
+
+void alloc_buffer(uv_handle_t *handle, size_t suggested_size, uv_buf_t *buf) {
+  *buf = uv_buf_init((char *)malloc(suggested_size), suggested_size);
+}
+
+void free_write_req(uv_write_t *req) {
+  write_req_t *wr = (write_req_t *)req;
+  free(wr->buf.base);
+  free(wr);
+}
+
+void on_stdout_write(uv_write_t *req, int status) { free_write_req(req); }
+
+void on_file_write(uv_write_t *req, int status) { free_write_req(req); }
+
+void write_data(uv_stream_t *dest, size_t size, uv_buf_t buf, uv_write_cb cb) {
+  write_req_t *req = (write_req_t *)malloc(sizeof(write_req_t));
+  req->buf = uv_buf_init((char *)malloc(size), size);
+  memcpy(req->buf.base, buf.base, size);
+  uv_write((uv_write_t *)req, (uv_stream_t *)dest, &req->buf, 1, cb);
+}
+
+void write_data2(StreamI *dest, size_t size, const BufT *buf,
+                 StreamI::WriteCallback &&cb) {
+  write_req_t *req = (write_req_t *)malloc(sizeof(write_req_t));
+  req->buf = uv_buf_init((char *)malloc(size), size);
+  memcpy(req->buf.base, buf->base, size);
+
+  dest->write((uv_write_t *)req, &req->buf, 1, std::forward<decltype(cb)>(cb));
+}
+
+void read_stdin(uv_stream_t *stream, ssize_t nread, const uv_buf_t *buf) {
+  if (nread < 0) {
+    if (nread == UV_EOF) {
+      // end of file
+      uv_close((uv_handle_t *)&stdin_pipe, NULL);
+      uv_close((uv_handle_t *)&stdout_pipe, NULL);
+      uv_close((uv_handle_t *)&file_pipe, NULL);
+    }
+  } else if (nread > 0) {
+    write_data((uv_stream_t *)&stdout_pipe, nread, *buf, on_stdout_write);
+    write_data((uv_stream_t *)&file_pipe, nread, *buf, on_file_write);
+  }
+
+  // OK to free buffer as write_data copies it.
+  if (buf->base)
+    free(buf->base);
+}
+
+void test_tee(LoopT *loop, const char *filename) {
+  PipeT stdin_pipe(loop, 0);
+  stdin_pipe.open(0);
+
+  PipeT stdout_pipe(loop, 0);
+  stdout_pipe.open(1);
+
+  uv_fs_t file_req;
+  int fd = uv_fs_open(loop->get(), &file_req, filename,
+                      O_CREAT | O_RDWR | O_TRUNC, 0644, NULL);
+  PipeT file_pipe(loop, 0);
+  file_pipe.open(fd);
+
+  stdin_pipe.readStart(
+      [](size_t len, BufT *buf) {
+        *buf = uv_buf_init((char *)malloc(len), len);
+      },
+      [&stdin_pipe, &stdout_pipe, &file_pipe](ssize_t nread, const BufT *buf) {
+        if (nread < 0) {
+          if (nread == UV_EOF) {
+            // end of file
+            stdin_pipe.close(
+                []() { std::cout << "stdin closed." << std::endl; });
+            stdout_pipe.close(
+                []() { std::cout << "stdout closed." << std::endl; });
+            file_pipe.close([]() { std::cout << "file closed." << std::endl; });
+          }
+        } else if (nread > 0) {
+          write_data2(&stdout_pipe, nread, buf,
+                      [](uv_write_t *req, int status) { free_write_req(req); });
+          write_data2(&file_pipe, nread, buf,
+                      [](uv_write_t *req, int status) { free_write_req(req); });
+        }
+
+        // OK to free buffer as write_data copies it.
+        if (buf->base)
+          free(buf->base);
+      });
+
+  loop->run(UV_RUN_DEFAULT);
+}
+
+// --
+
+int main(int argc, char *argv[]) {
   const unsigned int log_file_count = 5;
   nanolog::initialize(nanolog::GuaranteedLogger(), "/tmp/", "uvp", 1,
                       log_file_count);
 
   std::cout << "libuv version: " << Version().str() << std::endl;
-  // auto loop = LoopT::defaultLoop();
-  auto loop = std::make_unique<LoopT>();
+  auto loop = LoopT::defaultLoop();
+  // auto loop = std::make_unique<LoopT>();
 
-  // test_idle(loop);
-  test_timer(loop);
+  test_tee(loop.get(), argv[1]);
+  // test_cat(loop.get(), argv[1]);
+  // test_idle(loop.get());
+  // test_timer(loop.get());
 
   loop->close();
   return 0;
只在 /home/xt/dev/cpp/uv/. 存在：req.cpp
只在 /home/xt/dev/cpp/uv/. 存在：req.hpp
diff -ur ./utilites.cpp /home/xt/dev/cpp/uv/./utilites.cpp
--- ./utilites.cpp	2018-12-04 16:21:33.247383000 +0800
+++ /home/xt/dev/cpp/uv/./utilites.cpp	2018-12-05 11:10:00.949894101 +0800
@@ -12,7 +12,6 @@
 */
 // --
 
-// hex_dump is not a part of msgpack-c.
 std::ostream &hex_dump(std::ostream &o, std::string const &v) {
   std::ios::fmtflags f(o.flags());
   o << std::hex;
diff -ur ./utilites.hpp /home/xt/dev/cpp/uv/./utilites.hpp
--- ./utilites.hpp	2018-12-04 23:05:33.831175000 +0800
+++ /home/xt/dev/cpp/uv/./utilites.hpp	2018-12-05 10:55:26.641865693 +0800
@@ -12,6 +12,14 @@
     }                                                                          \
   } while (false)
 
+#define LOG_IF_ERROR_RETURN(e)                                                 \
+  do {                                                                         \
+    if (e) {                                                                   \
+      LOG_UV_ERROR(e);                                                         \
+      return (e);                                                              \
+    }                                                                          \
+  } while (false)
+
 #define LOG_IF_ERROR_EXIT(e)                                                   \
   do {                                                                         \
     if (e) {                                                                   \
diff -ur ./uv.cpp /home/xt/dev/cpp/uv/./uv.cpp
--- ./uv.cpp	2018-12-05 01:23:25.978170470 +0800
+++ /home/xt/dev/cpp/uv/./uv.cpp	2018-12-06 01:13:44.088327318 +0800
@@ -1,3 +1,4 @@
+// #include <req.hpp>
 #include <uv.hpp>
 #include <utilites.hpp>
 
@@ -13,29 +14,93 @@
   }
   std::unique_ptr<uv_loop_t> _loop;
   bool _owner;
+  void *_data;
+  WalkCallback _walkCallback;
+  static void walk_callback(uv_handle_t *handle, void *arg);
 };
 
+void LoopT::Impl::walk_callback(uv_handle_t *handle, void *arg) {
+  auto h = (HandleI *)uv_handle_get_data(handle);
+  auto p = (LoopT *)uv_loop_get_data(uv_handle_get_loop(handle));
+  p->_impl->_walkCallback(h, arg);
+}
+
 // --
 
 std::unique_ptr<LoopT> LoopT::defaultLoop() {
   uv_loop_t *loop = uv_default_loop();
+  if (!loop) {
+    LOG_IF_ERROR_EXIT(UV_ENOMEM);
+  }
   return std::unique_ptr<LoopT>(new LoopT(loop));
 }
 
+size_t LoopT::size() { return uv_loop_size(); }
+
 LoopT::LoopT() : _impl(std::make_unique<LoopT::Impl>()) {
-  uv_loop_init(_impl->_loop.get());
+  int r = uv_loop_init(_impl->_loop.get());
+  LOG_IF_ERROR_EXIT(r);
+
+  uv_loop_set_data(_impl->_loop.get(), this);
 }
 
-LoopT::LoopT(uv_loop_t *l) : _impl(std::make_unique<LoopT::Impl>(l)) {}
+LoopT::LoopT(uv_loop_t *l) : _impl(std::make_unique<LoopT::Impl>(l)) {
+  uv_loop_set_data(_impl->_loop.get(), this);
+}
 
 LoopT::~LoopT() {}
 
-int LoopT::close() { return uv_loop_close(_impl->_loop.get()); }
+int LoopT::configure(std::initializer_list<LoopOperation> options) {
+  int r = 0;
+  for (auto ptr = options.begin(); ptr != options.end(); ptr++) {
+    r = uv_loop_configure(_impl->_loop.get(), *ptr);
+    LOG_IF_ERROR_RETURN(r);
+  }
+  return r;
+}
+
+int LoopT::close() {
+  int r = uv_loop_close(_impl->_loop.get());
+  LOG_IF_ERROR(r);
+  return r;
+}
+
+int LoopT::run(LoopT::RunMode mode) {
+  int r = uv_run(_impl->_loop.get(), mode);
+  LOG_IF_ERROR(r);
+  return r;
+}
+
+bool LoopT::alive() const { return uv_loop_alive(_impl->_loop.get()); }
 
-int LoopT::run(LoopT::RunMode mode) { return uv_run(_impl->_loop.get(), mode); }
+void LoopT::stop() { uv_stop(_impl->_loop.get()); }
 
-uint64_t LoopT::now() const {
-  return uv_now(get());
+int LoopT::backendFd() const { return uv_backend_fd(_impl->_loop.get()); }
+
+int LoopT::backendTimeout() const {
+  return uv_backend_timeout(_impl->_loop.get());
+}
+
+uint64_t LoopT::now() const { return uv_now(get()); }
+
+void LoopT::updateTime() { return uv_update_time(_impl->_loop.get()); }
+
+void LoopT::walk(WalkCallback &&cb, void *arg) {
+  _impl->_walkCallback = std::forward<WalkCallback>(cb);
+  uv_walk(_impl->_loop.get(), LoopT::Impl::walk_callback, arg);
+}
+
+int LoopT::fork() {
+  int r = uv_loop_fork(_impl->_loop.get());
+  LOG_IF_ERROR(r);
+  return r;
+}
+
+void *LoopT::data() const { return _impl->_data; }
+
+void *LoopT::data(void *data) {
+  _impl->_data = data;
+  return data;
 }
 
 uv_loop_t *LoopT::get() const { return _impl->_loop.get(); }
@@ -53,12 +118,12 @@
 
 void HandleI::Impl::alloc_callback(uv_handle_t *handle, size_t suggested_size,
                                    BufT *buf) {
-  HandleT *h = (HandleT *)uv_handle_get_data(handle);
-  h->_impl->_allocCallback(handle, suggested_size, buf);
+  auto h = (HandleI *)uv_handle_get_data(handle);
+  h->_impl->_allocCallback(suggested_size, buf);
 }
 
 void HandleI::Impl::close_callback(uv_handle_t *handle) {
-  HandleT *h = (HandleT *)uv_handle_get_data(handle);
+  auto h = (HandleI *)uv_handle_get_data(handle);
   h->_impl->_closeCallback();
 }
 
@@ -99,9 +164,9 @@
 
 int HandleI::fileno(OsFdT *fd) { return uv_fileno(getHandle(), fd); }
 
-std::unique_ptr<LoopT> HandleI::loop() const {
+LoopT *HandleI::loop() const {
   uv_loop_t *loop = uv_handle_get_loop(getHandle());
-  return std::unique_ptr<LoopT>(new LoopT(loop));
+  return (LoopT *)uv_loop_get_data(loop);
 }
 
 void *HandleI::data() const { return _impl->_data; }
@@ -114,7 +179,7 @@
 
 uv_handle_t *HandleT::getHandle() const { return (uv_handle_t *)&_handle; }
 
-HandleT::HandleT() {}
+HandleT::HandleT() { uv_handle_set_data(getHandle(), this); }
 
 HandleT::~HandleT() {}
 
@@ -126,7 +191,7 @@
 };
 
 void IdleI::Impl::idle_callback(uv_idle_t *idle) {
-  auto p = (IdleT *)uv_handle_get_data((uv_handle_t *)idle);
+  auto p = (IdleI *)uv_handle_get_data((uv_handle_t *)idle);
   p->_impl->_idleCallback();
 }
 
@@ -139,13 +204,13 @@
 int IdleI::start(IdleCallback &&cb) {
   _impl->_idleCallback = std::forward<IdleCallback>(cb);
   int r = uv_idle_start(getIdle(), IdleI::Impl::idle_callback);
-  LOG_IF_ERROR_EXIT(r);
+  LOG_IF_ERROR(r);
   return r;
 }
 
 int IdleI::stop() {
   int r = uv_idle_stop(getIdle());
-  LOG_IF_ERROR_EXIT(r);
+  LOG_IF_ERROR(r);
   return r;
 }
 
@@ -155,7 +220,7 @@
 
 uv_idle_t *IdleT::getIdle() const { return (uv_idle_t *)&_idle; }
 
-IdleT::IdleT(const std::unique_ptr<LoopT> &loop) {
+IdleT::IdleT(LoopT *loop) {
   int r = uv_idle_init(loop->get(), &_idle);
   LOG_IF_ERROR_EXIT(r);
 
@@ -172,7 +237,7 @@
 };
 
 void TimerI::Impl::timer_callback(uv_timer_t *handle) {
-  auto p = (TimerT *)uv_handle_get_data((uv_handle_t *)handle);
+  auto p = (TimerI *)uv_handle_get_data((uv_handle_t *)handle);
   p->_impl->_timerCallback();
 }
 
@@ -187,19 +252,19 @@
   _impl->_timerCallback = std::forward<decltype(cb)>(cb);
   int r =
       uv_timer_start(getTimer(), TimerI::Impl::timer_callback, timeout, repeat);
-  LOG_IF_ERROR_EXIT(r);
+  LOG_IF_ERROR(r);
   return r;
 }
 
 int TimerI::stop() {
   int r = uv_timer_stop(getTimer());
-  LOG_IF_ERROR_EXIT(r);
+  LOG_IF_ERROR(r);
   return r;
 }
 
 int TimerI::again() {
   int r = uv_timer_again(getTimer());
-  LOG_IF_ERROR_EXIT(r);
+  LOG_IF_ERROR(r);
   return r;
 }
 
@@ -215,7 +280,7 @@
 
 uv_timer_t *TimerT::getTimer() const { return (uv_timer_t *)&_timer; }
 
-TimerT::TimerT(const std::unique_ptr<LoopT> &loop) {
+TimerT::TimerT(LoopT *loop) {
   int r = uv_timer_init(loop->get(), &_timer);
   LOG_IF_ERROR_EXIT(r);
 
@@ -225,3 +290,160 @@
 TimerT::~TimerT() {}
 
 // --
+
+struct StreamI::Impl {
+  ReadCallback _readCallback;
+  WriteCallback _writeCallback;
+  ConnectCallback _connectCallback;
+  ShutdownCallback _shutdownCallback;
+  ConnectionCallback _connectionCallback;
+
+  static void read_callback(uv_stream_t *stream, ssize_t nread,
+                            const BufT *buf);
+  static void write_callback(uv_write_t *req, int status);
+  static void shutdown_callback(uv_shutdown_t *req, int status);
+  static void connection_callback(uv_stream_t *server, int status);
+};
+
+void StreamI::Impl::read_callback(uv_stream_t *stream, ssize_t nread,
+                                  const BufT *buf) {
+  auto p = (StreamI *)uv_handle_get_data((uv_handle_t *)stream);
+  p->_impl->_readCallback(nread, buf);
+}
+
+void StreamI::Impl::write_callback(uv_write_t *req, int status) {
+  uv_stream_t *h = req->handle;
+  auto p = (StreamI *)uv_handle_get_data((uv_handle_t *)h);
+  p->_impl->_writeCallback(req, status);
+}
+
+void StreamI::Impl::shutdown_callback(uv_shutdown_t *req, int status) {
+  uv_stream_t *h = req->handle;
+  auto p = (StreamI *)uv_handle_get_data((uv_handle_t *)h);
+  p->_impl->_shutdownCallback(status);
+}
+
+void StreamI::Impl::connection_callback(uv_stream_t *server, int status) {
+  auto p = (StreamI *)uv_handle_get_data((uv_handle_t *)server);
+  p->_impl->_connectionCallback(status);
+}
+
+StreamI::StreamI() : _impl(std::make_unique<StreamI::Impl>()) {}
+
+StreamI::~StreamI() {}
+
+int StreamI::shutdown(uv_shutdown_t *req, StreamI::ShutdownCallback &&cb) {
+  _impl->_shutdownCallback = std::forward<decltype(cb)>(cb);
+  int r = uv_shutdown(req, getStream(),
+                      StreamI::Impl::shutdown_callback);
+  LOG_IF_ERROR(r);
+  return r;
+}
+
+int StreamI::listen(int backlog, StreamI::ConnectionCallback &&cb) {
+  _impl->_connectionCallback = std::forward<decltype(cb)>(cb);
+  int r = uv_listen(getStream(), backlog, StreamI::Impl::connection_callback);
+  LOG_IF_ERROR(r);
+  return r;
+}
+
+int StreamI::accept(StreamT *client) {
+  int r = uv_accept(getStream(), client->getStream());
+  LOG_IF_ERROR(r);
+  return r;
+}
+
+int StreamI::readStart(StreamI::AllocCallback &&alloc,
+                       StreamI::ReadCallback &&cb) {
+  HandleI::_impl->_allocCallback = std::forward<decltype(alloc)>(alloc);
+  _impl->_readCallback = std::forward<decltype(cb)>(cb);
+  int r = uv_read_start(getStream(), HandleI::Impl::alloc_callback,
+                        StreamI::Impl::read_callback);
+  LOG_IF_ERROR(r);
+  return r;
+}
+
+int StreamI::readStop() {
+  int r = uv_read_stop(getStream());
+  LOG_IF_ERROR(r);
+  return r;
+}
+
+int StreamI::write(uv_write_t *req, BufT bufs[], unsigned int nbufs,
+                   StreamI::WriteCallback &&cb) {
+  _impl->_writeCallback = std::forward<decltype(cb)>(cb);
+  int r = uv_write(req, getStream(), bufs, nbufs,
+                   StreamI::Impl::write_callback);
+  LOG_IF_ERROR(r);
+  return r;
+}
+
+int StreamI::write2(uv_write_t *req, BufT bufs[], unsigned int nbufs,
+                    StreamT *sendstream, WriteCallback &&cb) {
+  _impl->_writeCallback = std::forward<decltype(cb)>(cb);
+  int r = uv_write2(req, getStream(), bufs, nbufs,
+                    sendstream->getStream(), StreamI::Impl::write_callback);
+  LOG_IF_ERROR(r);
+  return r;
+}
+
+int StreamI::tryWrite(BufT bufs[], unsigned int nbufs) {
+  int r = uv_try_write(getStream(), bufs, nbufs);
+  LOG_IF_ERROR(r);
+  return r;
+}
+
+int StreamI::isReadable() const { return uv_is_readable(getStream()); }
+
+int StreamI::isWritable() const { return uv_is_writable(getStream()); }
+
+int StreamI::setBlocking(int blocking) {
+  int r = uv_stream_set_blocking(getStream(), blocking);
+  LOG_IF_ERROR(r);
+  return r;
+}
+
+int StreamI::getWriteQueueSize() const {
+  return uv_stream_get_write_queue_size(getStream());
+}
+
+// --
+
+uv_handle_t *StreamT::getHandle() const { return (uv_handle_t *)&_stream; }
+
+uv_stream_t *StreamT::getStream() const { return (uv_stream_t *)&_stream; }
+
+StreamT::StreamT() { uv_handle_set_data((uv_handle_t *)&_stream, this); }
+
+StreamT::~StreamT() {}
+
+// --
+
+int PipeI::open(PipeI::File file) {
+  int r = uv_pipe_open(getPipe(), file);
+  LOG_IF_ERROR(r);
+  return r;
+}
+
+int PipeI::bind(const char *name) {
+  int r = uv_pipe_bind(getPipe(), name);
+  LOG_IF_ERROR(r);
+  return r;
+}
+
+// --
+
+uv_handle_t *PipeT::getHandle() const { return (uv_handle_t *)&_pipe; }
+
+uv_stream_t *PipeT::getStream() const { return (uv_stream_t *)&_pipe; }
+
+uv_pipe_t *PipeT::getPipe() const { return (uv_pipe_t *)&_pipe; }
+
+PipeT::PipeT(LoopT *loop, int ipc) {
+  int r = uv_pipe_init(loop->get(), &_pipe, ipc);
+  LOG_IF_ERROR_EXIT(r);
+
+  uv_handle_set_data(getHandle(), this);
+}
+
+PipeT::~PipeT() {}
\ 文件尾没有换行符
diff -ur ./uv.hpp /home/xt/dev/cpp/uv/./uv.hpp
--- ./uv.hpp	2018-12-05 00:55:34.767422000 +0800
+++ /home/xt/dev/cpp/uv/./uv.hpp	2018-12-06 01:13:44.088327318 +0800
@@ -1,9 +1,13 @@
+#pragma once
+
 #include <uv.h>
 
 #include <functional>
 #include <memory>
 #include <initializer_list>
 
+// #include <req.hpp>
+
 // --
 
 using BufT = uv_buf_t;
@@ -18,7 +22,7 @@
   using RunMode = uv_run_mode;
   using LoopOperation = uv_loop_option;
 
-  using WalkCallback = std::function<void(void *)>;
+  using WalkCallback = std::function<void(HandleI *, void *)>;
 
   static std::unique_ptr<LoopT> defaultLoop();
   static size_t size();
@@ -46,23 +50,22 @@
 
 private:
   friend std::unique_ptr<LoopT> defaultLoop();
-  friend class HandleI;
   LoopT(uv_loop_t *l);
 };
 
 // --
 
 class HandleI {
+protected:
   class Impl;
   std::unique_ptr<Impl> _impl;
 
-protected:
   virtual uv_handle_t *getHandle() const = 0;
 
 public:
   using Type = uv_handle_type;
 
-  using AllocCallback = std::function<void(uv_handle_t *, size_t, BufT *)>;
+  using AllocCallback = std::function<void(size_t, BufT *)>;
   using CloseCallback = std::function<void()>;
 
   static size_t size(Type t);
@@ -86,7 +89,7 @@
   // The following handles are supported: TCP, pipes, TTY, UDP and poll. Passing
   // any other handle type will fail with UV_EINVAL.
   int fileno(OsFdT *fd);
-  std::unique_ptr<LoopT> loop() const;
+  LoopT *loop() const;
   void *data() const;
   void *data(void *data);
   Type type() const;
@@ -130,7 +133,7 @@
   virtual uv_idle_t *getIdle() const override;
 
 public:
-  IdleT(const std::unique_ptr<LoopT> &loop);
+  IdleT(LoopT *loop);
   virtual ~IdleT();
 };
 
@@ -164,8 +167,91 @@
   virtual uv_timer_t *getTimer() const override;
 
 public:
-  TimerT(const std::unique_ptr<LoopT> &loop);
+  TimerT(LoopT *loop);
   virtual ~TimerT();
 };
 
-// --
\ 文件尾没有换行符
+// --
+
+class StreamT;
+class StreamI : public HandleI {
+  class Impl;
+  std::unique_ptr<Impl> _impl;
+
+protected:
+  virtual uv_stream_t *getStream() const = 0;
+
+public:
+  
+  using ReadCallback = std::function<void(ssize_t, const BufT *)>;
+  using WriteCallback = std::function<void(uv_write_t*, int)>;
+  using ConnectCallback = std::function<void(int)>;
+  using ShutdownCallback = std::function<void(int)>;
+  using ConnectionCallback = std::function<void(int)>;
+
+  StreamI();
+  virtual ~StreamI();
+
+  int shutdown(uv_shutdown_t *req, ShutdownCallback &&cb);
+  int listen(int backlog, ConnectionCallback &&cb);
+  int accept(StreamT *client);
+  int readStart(AllocCallback &&alloc, ReadCallback &&cb);
+  int readStop();
+  int write(uv_write_t* req, BufT bufs[], unsigned int nbufs, WriteCallback &&cb);
+  int write2(uv_write_t* req, BufT bufs[], unsigned int nbufs, StreamT *sendstream,
+             WriteCallback &&cb);
+  int tryWrite(BufT bufs[], unsigned int nbufs);
+  int isReadable() const;
+  int isWritable() const;
+  int setBlocking(int blocking);
+  int getWriteQueueSize() const;
+};
+
+class StreamT : public StreamI {
+  friend class StreamI;
+  uv_stream_t _stream;
+
+protected:
+  virtual uv_handle_t *getHandle() const;
+  virtual uv_stream_t *getStream() const;
+
+public:
+  StreamT();
+  virtual ~StreamT();
+};
+
+// --
+
+class PipeI : public StreamI {
+protected:
+  // class Impl;
+  // std::unique_ptr<Impl> _impl;
+
+  virtual uv_pipe_t *getPipe() const = 0;
+
+public:
+  using File = uv_file;
+  
+  int open(File file);
+  int bind(const char* name);
+  // int connect(ConnectT* req, const char* name, ConnectCallback&& cb);
+  // int getSockname(char* buffer, size_t* size) const;
+  // int getPeername(char* buffer, size_t* size) const;
+  // int pendingInstances(int count);
+  // int pendingCount(PipeT* pipe);
+  // HandleI::Type pendingType();
+  // int chmod();
+};
+
+class PipeT : public PipeI {
+  uv_pipe_t _pipe;
+
+protected:
+  virtual uv_handle_t *getHandle() const override;
+  virtual uv_stream_t* getStream() const override;
+  virtual uv_pipe_t *getPipe() const override;
+
+public:
+  PipeT(LoopT *loop, int ipc);
+  ~PipeT();
+};
\ 文件尾没有换行符
diff -ur ./ver.h /home/xt/dev/cpp/uv/./ver.h
--- ./ver.h	2018-12-05 01:23:25.978170470 +0800
+++ /home/xt/dev/cpp/uv/./ver.h	2018-12-06 01:46:01.557360359 +0800
@@ -4,6 +4,6 @@
 #define VERSION_MAJOR 0
 #define VERSION_MINOR 0
 #define VERSION_PATCH 0
-#define VERSION_BUILD 225
+#define VERSION_BUILD 311
 
 #endif
只在 /home/xt/dev/cpp/uv/. 存在：.vscode
