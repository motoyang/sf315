[ Docs ] [ txt | pdf ] [ draft-ietf-tls -... ] [ 追踪者 ] [ 知识产权 ] [ 勘误表 ] 

  


这是适用于机器翻译的Internet RFC的修改版本。 原始版本可在此处获得： RFC8446 




建议标准 
勘误存在 
互联网工程任务组（IETF）E。Rescorla
征求意见：8446 Mozilla
已淘汰：2 0177年8月5077,5246,6961
更新： 5705,6066
类别：标准跟踪
 ISSN：2070-1721


        
传输层安全性（TLS）协议版本1.3 

抽象 

本文档规定了传输层安全性（TLS）协议的1.3版。 TLS允许客户端/服务器应用程序通过Internet进行通信，旨在防止窃听，篡改和消息伪造。 

本文档更新了RFC 5705和6066，并废弃了RFC 5077,5246和6961.本文档还规定了TLS 1.2实现的新要求。 

本备忘录的状态 

这是Internet标准跟踪文档。 

本文档是Internet工程任务组（IETF）的产品。 它代表了IETF社区的共识。 它已经过公众审查，并已获得互联网工程指导小组（IESG）的批准发布。 有关Internet标准的更多信息，请参见RFC 7841的第2节 。 

有关本文档的当前状态，任何勘误以及如何提供反馈的信息，请访问https://www.rfc-editor.org/info/rfc8446 。
 Rescorla Standards Track [第1页] 
 
 RFC 8446 TLS 2018年8月
版权声明 

版权所有（c）2018 IETF Trust和被确认为文件作者的人员。 版权所有。 

本文档受BCP 78和IETF Trust有关IETF文件的法律规定（ https://trustee.ietf.org/license-info ）的约束，该文件自本文件发布之日起生效。 请仔细阅读这些文档，因为它们描述了您对本文档的权利和限制。 从本文档中提取的代码组件必须包含信任法律规定第4.e节中所述的简化BSD许可文本，并且不提供简化BSD许可中所述的保证。 

本文档可能包含IETF文档或IETF贡献的材料，这些材料在2008年11月10日之前发布或公开发布。控制本部分材料版权的人员可能未授予IETF Trust允许修改此类材料的权利在IETF标准流程之外。 如果没有从控制此类材料版权的人那里获得足够的许可，本文档不得在IETF标准流程之外进行修改，并且不得在IETF标准流程之外创建其衍生作品，除非格式化为作为RFC发布或将其翻译成英语以外的语言。
 Rescorla标准轨道[第2页] 
 
 RFC 8446 TLS 2018年8月
目录 

1 。 介绍 ................................................. ...... 6 
1.1 。 公约和术语................................ 7 
1.2 。 与TLS 1.2的主要区别............................. 8 
1.3 。 更新影响TLS 1.2 .................................. 9 
2 。 协议概述.............................................. 10 
2.1 。 DHE份额不正确....................................... 14 
2.2 。 恢复和预共享密钥（PSK）....................... 15 
2.3 。 0-RTT数据.............................................. .. 17 
3 。 演讲语言.......................................... 19 
3.1 。 基本块尺寸.......................................... 19 
3.2 。 杂项............................................. 20 
3.3 。 数字................................................. .. 20 
3.4 。 矢量................................................. .. 20 
3.5 。 枚举............................................... 21 
3.6 。 构造类型......................................... 22 
3.7 。 常数................................................. 23 
3.8 。 变种................................................. .23 
4 。 握手协议............................................. 24 
4.1 。 密钥交换消息..................................... 25 
4.1.1 。 密码协商.......................... 26 
4.1.2 。 客户你好....................................... 27 
4.1.3 。 服务器你好....................................... 31 
4.1.4 。 你好重试请求................................ 33 
4.2 。 扩展................................................ 35 
4.2.1 。 支持的版本................................. 39 
4.2.2 。 Cookie ............................................. 40 
4.2.3 。 签名算法............................... 41 
4.2.4 。 证书颁发机构............................ 45 
4.2.5 。 OID过滤器........................................ 45 
4.2.6 。 握手后客户端验证............... 47 
4.2.7 。 支持的组................................... 47 
4.2.8 。 主要分享.......................................... 48 
4.2.9 。 预共享密钥交换模式...................... 51 
4.2.10 。 早期数据显示............................. 52 
4.2.11 。 预共享密钥扩展.......................... 55 
4.3 。 服务器参数......................................... 59 
4.3.1 。 加密扩展............................... 60 
4.3.2 。 证书申请................................ 60 
4.4 。 验证消息................................... 61 
4.4.1 。 Transcript Hash ................................ 63 
4.4.2 。 证书........................................ 64 
4.4.3 。 证书验证................................. 69 
4.4.4 。 完成........................................... 71 
4.5 。 早期数据结束......................................... 72
 Rescorla标准轨道[第3页] 
 
 RFC 8446 TLS 2018年8月

4.6 。 握手后信息................................... 73 
4.6.1 。 新会话票据消息......................... 73 
4.6.2 。 握手后认证...................... 75 
4.6.3 。 密钥和初始化矢量更新............... 76 
5 。 记录协议................................................ 77 
5.1 。 记录层.............................................. 78 
5.2 。 记录有效载荷保护................................. 80 
5.3 。 每记录现时.......................................... 82 
5.4 。 记录填充............................................ 83 
5.5 。 关键用途的限制....................................... 84 
6 。 警报协议................................................ .85 
6.1 。 关闭警报............................................ 87 
6.2 。 错误提醒.............................................. 88 
7 。 密码计算..................................... 90 
7.1 。 关键时间表.............................................. 91 
7.2 。 更新交通秘密.................................. 94 
7.3 。 交通密钥计算................................... 95 
7.4 。 （EC）DHE共享秘密计算......................... 95 
7.4.1 。 有限域Diffie-Hellman ........................ 95 
7.4.2 。 椭圆曲线Diffie-Hellman ...................... 96 
7.5 。 出口商................................................. 97 
8 。 0-RTT和Anti-Replay .......................................... 98 
8.1 。 一次性门票........................................ 99 
8.2 。 客户Hello记录.................................... 99 
8.3 。 新鲜度检查......................................... 101 
9 。 合规要求........................................ 102 
9.1 。 强制实施密码套件..................... 102 
9.2 。 强制执行扩展........................ 103 
9.3 。 协议不变量...................................... 104 
10 。 安全考虑因素...................................... 106 
11 。 IANA注意事项.......................................... 106 
12 。 参考................................................. .. 109 
12.1 。 规范性参考文献.................................... 109 
12.2 。 信息参考.................................. 112 
附录A. 国家机器........................................ 120 
A.1 。 客户................................................. ...... 120 A.2 。 服务器................................................. ...... 121 
附录B. 协议数据结构和常量值......... 122 
B.1 。 记录层.............................................. 122 B. .2 。 警报信息............................................ 123 B.3 。 握手协议........................................ 124 B.3.1 。 密钥交换消息................................. 125 B.3.2 。 服务器参数消息............................ 131 B.3.3 。 验证消息............................... 132 B.3.4 。 机票设施.................................. 132 B.3.5 。 更新钥匙......................................... 133 
B.4 。 密码套房............................................. 133
 Rescorla标准轨道[第4页] 
 
 RFC 8446 TLS 2018年8月
附录C. 实施说明................................. 134 
C.1 。 随机数生成和播种...................... 134 C.2 。 证书和认证........................... 135 C.3 。 实施陷阱................................... 135 C.4 。 客户跟踪预防................................ 137 C.5 。 未经认证的操作................................. 137 
附录D. 向后兼容性............................... 138 
D.1 。 与旧服务器协商.......................... 139 D.2 。 与老客户谈判.......................... 139 D.3 。 0-RTT向后兼容性.............................. 140 D.4 。 Middlebox兼容模式.............................. 140 D.5 。 与向后兼容性相关的安全限制... 141 
附录E. 安全属性概述...................... 142 
E.1 。 握手................................................. 142 
E.1.1 。 主要推导和HKDF ............................... 145 E.1.2 。 客户认证................................. 146 E.1.3 。 0-RTT ............................................... .. 146 E.1.4 。 出口商独立................................. 146 E.1.5 。 妥协后安全.............................. 146 E.1.6 。 外部参考................................... 147 
E.2 。 记录层.............................................. 147 
E.2.1 。 外部参考................................... 148 
E.3 。 交通分析.......................................... 148 E.4 。 侧通道攻击...................................... 149 E.5 。 重播0-RTT上的攻击................................... 150 
E.5.1 。 重播和出口商.................................. 151 
E.6 。 PSK身份暴露..................................... 152 E.7 。 分享PSK .............................................. 152 E .8 。 对静态RSA的攻击..................................... 152贡献者....... .............................................. 153作者的地址。 ................................................ 160
 Rescorla Standards Track [第5页] 
 
 RFC 8446 TLS 2018年8月

1 。 介绍 

TLS的主要目标是在两个通信对等体之间提供安全通道; 底层传输的唯一要求是可靠的有序数据流。 具体而言，安全通道应提供以下属性： 

- 身份验证：通道的服务器端始终进行身份验证; 客户端可选择进行身份验证。 认证可以通过非对称密码术（例如，RSA [RSA] ，椭圆曲线数字签名算法（ECDSA） [ECDSA]或Edwards曲线数字签名算法（EdDSA） [RFC8032] ）或对称预共享密钥（ PSK）。 

- 机密性：建立后通过信道发送的数据仅对端点可见。 TLS不会隐藏它传输的数据的长度，尽管端点能够填充TLS记录以掩盖长度并改进对流量分析技术的保护。 

- 完整性：未经检测，攻击者无法修改建立后通过信道发送的数据。 

即使面对完全控制网络的攻击者，这些属性也应该是正确的，如[RFC3552]中所述 。 有关相关安全属性的更完整声明，请参阅附录E. 

TLS包含两个主要组件： 

- 握手协议（ 第4节 ），用于验证通信方，协商加密模式和参数，以及建立共享密钥材料。 握手协议旨在抵制篡改; 如果连接没有受到攻击，主动攻击者不应该强制对等方协商不同的参数。 

- 记录协议（ 第5节 ），它使用握手协议建立的参数来保护通信对等体之间的流量。 记录协议将流量划分为一系列记录，每个记录使用流量密钥独立保护。 TLS是独立于应用协议的; 更高级别的协议可以透明地层叠在TLS之上。 但是，TLS标准没有规定协议如何通过TLS增加安全性; 如何启动TLS握手以及如何解释交换的身份验证证书留给TLS之上运行的协议的设计者和实现者的判断。
 Rescorla标准轨道[第6页] 
 
 RFC 8446 TLS 2018年8月

本文档定义了TLS 1.3版。 虽然TLS 1.3与以前的版本不直接兼容，但所有版本的TLS都包含一个版本控制机制，允许客户端和服务器在两个对等方都支持的情况下互操作协商通用版本。 

本文档取代并废弃以前版本的TLS，包括版本1.2 [RFC5246] 。 它还废弃了[RFC5077]中定义的TLS票证机制，并将其替换为第2.2节中定义的机制。 由于TLS 1.3更改了密钥的派生方式，因此会按照第7.5节中的说明更新[RFC5705] 。 它还会更改在线证书状态协议（OCSP）消息的携带方式，因此会更新[RFC6066]并废弃[RFC6961] ，如第4.4.2.1节所述。 
 1.1 。  公约和术语

关键词“必须”，“必须”，“不需要”，“应该”，“不应该”，“应该”，“不应该”，“推荐”，“不推荐”，“可以”和“可选” “在本文档中，只有当它们出现在所有大写字母中时才会按照BCP 14 [RFC2119] [RFC8174]中的描述进行解释，如此处所示。 

使用以下术语： 

client：启动TLS连接的端点。 

connection：两个端点之间的传输层连接。 

endpoint：连接的客户端或服务器。 

handshake：客户端和服务器之间的初始协商，用于在TLS中建立其后续交互的参数。 

peer：端点。 在讨论特定端点时，“同行” 
指的是不是讨论主要主题的终点。 receiver：接收记录的端点。
 Rescorla标准轨道[第7页] 
 
 RFC 8446 TLS 2018年8月

sender：发送记录的端点。 

server：未启动TLS连接的端点。 
 1.2 。  与TLS 1.2的主要区别

以下是TLS 1.2和TLS 1.3之间主要功能差异的列表。 它并非详尽无遗，并且存在许多细微差别。 

- 所有被认为是遗留算法的算法都修复了支持的对称加密算法列表。 剩下的都是带有关联数据（AEAD）算法的经过身份验证的加密。 密码套件概念已经改变，以将认证和密钥交换机制与记录保护算法（包括密钥长度）和要与密钥导出功能和握手消息认证码（MAC）一起使用的散列分开。 

- 增加了零往返时间（0-RTT）模式，在某些应用数据的连接设置中节省了往返，但代价是某些安全属性。 

- 已删除静态RSA和Diffie-Hellman密码套件; 所有基于公钥的密钥交换机制现在都提供了前瞻性保密。 

- ServerHello之后的所有握手消息现在都已加密。 新引入的EncryptedExtensions消息允许以前在ServerHello中以明文形式发送的各种扩展也享有机密性保护。 

- 密钥派生函数已经过重新设计。 新设计使密码学家能够更轻松地进行分析，因为它们具有改进的密钥分离特性。 基于HMAC的提取和扩展密钥导出函数（HKDF）用作基础原语。 

- 握手状态机已经过重大调整，可以更加一致，并可以删除多余的消息，例如ChangeCipherSpec（除非中间件兼容性需要）。 

- 椭圆曲线算法现在在基本规范中，并且包括新的签名算法，例如EdDSA。 TLS 1.3删除了点格式协商，支持每条曲线的单点格式。 



 Rescorla标准轨道[第8页] 
 
 RFC 8446 TLS 2018年8月


- 进行了其他加密改进，包括更改RSA填充以使用RSA概率签名方案（RSASSA-PSS），以及删除压缩，数字签名算法（DSA）和自定义短暂Diffie-Hellman（DHE）组。 

- 不推荐使用TLS 1.2版本协商机制，而是使用扩展中的版本列表。 这增加了与错误实现版本协商的现有服务器的兼容性。 

- 具有和不具有服务器端状态的会话恢复以及早期TLS版本的基于PSK的密码套件已被单个新的PSK交换替换。 

- 已更新引用以指向适当的RFC的更新版本（例如， RFC 5280而不是RFC 3280 ）。 
 1.3 。  更新影响TLS 1.2

本文档定义了一些可选择影响TLS 1.2实现的更改，包括那些不支持TLS 1.3的更改： 

- 版本降级保护机制在4.1.3节中描述。 

- RSASSA-PSS签名方案在4.2.3节中定义。 

- “supported_versions”ClientHello扩展可用于协商要使用的TLS版本，优先于ClientHello的legacy_version字段。 

- “signature_algorithms_cert”扩展允许客户端指示它可以在X.509证书中验证哪些签名算法。

此外，本文档阐明了早期版本TLS的一些合规性要求; 见9.3节 。
 Rescorla标准轨道[第9页] 
 
 RFC 8446 TLS 2018年8月

2 。 协议概述 

安全通道使用的加密参数由TLS握手协议产生。 当首次相互通信时，客户端和服务器使用该TLS子协议。 握手协议允许对等体协商协议版本，选择加密算法，可选地相互认证，以及建立共享秘密密钥材料。 握手完成后，对等方使用已建立的密钥来保护应用层流量。 

握手或其他协议错误失败会触发连接终止，可选择在警报消息之前（ 第6节 ）。 

TLS支持三种基本密钥交换模式： 

- （EC）DHE（Diffie-Hellman在有限域或椭圆曲线上） 

- 仅限PSK 

- 带（EC）DHE的PSK下面的图1显示了基本的完整TLS握手：
 Rescorla Standards Track [第10页] 
 
 RFC 8446 TLS 2018年8月

客户端服务器 

Key ^ ClientHello Exch | + key_share * 
| + signature_algorithms *
      |  + psk_key_exchange_modes *
      v + pre_shared_key * -------->
                                                   ServerHello ^ Key
+ key_share * | EXCH 
+ pre_shared_key * v 
{EncryptedExtensions} ^ Server {CertificateRequest *} v Params 
{证书*} ^ 
{CertificateVerify *} | 验证
                                                    {完成} v
                                <-------- [申请资料*]
      ^ {证书*}
Auth | {CertificateVerify *}
      v {完成} -------->
        [应用数据] <-------> [应用数据]

+表示在中发送的值得注意的扩展名 
先前提到的消息。 

*表示并非总是发送的可选或依赖于情境的消息/扩展。 

{}表示使用密钥保护的消息 
派生自[ sender ] _handshake_traffic_secret。 

[]表示使用密钥保护的消息 
派生自[ sender ] _application_traffic_secret_N。 

图1：完整TLS握手的消息流 

握手可以被认为有三个阶段（如上图所示）： 

- 密钥交换：建立共享密钥材料并选择加密参数。 此阶段之后的所有内容都已加密。 

- 服务器参数：建立其他握手参数（客户端是否经过身份验证，应用层协议支持等）。 



 Rescorla标准轨道[第11页] 
 
 RFC 8446 TLS 2018年8月


- 身份验证：验证服务器（以及可选的客户端）并提供密钥确认和握手完整性。 

在密钥交换阶段，客户端发送ClientHello（ 第4.1.2节 ）消息，该消息包含随机现时（ClientHello.random）; 它提供的协议版本; 对称密码/ HKDF哈希对列表; 一组Diffie-Hellman密钥共享（在“key_share”（ 第4.2.8节 ）扩展中），一组预共享密钥标签（在“pre_shared_key”（ 第4.2.11节 ）扩展中）或两者; 以及可能的附加扩展。 还可以存在用于中间盒兼容性的附加字段和/或消息。 

服务器处理ClientHello并确定连接的相应加密参数。 然后它使用自己的ServerHello响应（ 第4.1.3节 ），它指示协商的连接参数。 ClientHello和ServerHello的组合确定共享密钥。 如果正在使用（EC）DHE密钥建立，那么ServerHello包含一个“key_share”扩展，其中包含服务器的临时Diffie-Hellman共享; 服务器的共享必须与客户端的一个共享在同一组中。 如果正在使用PSK密钥建立，则ServerHello包含一个“pre_shared_key”扩展，指示选择了哪个客户端提供的PSK。 注意，实现可以一起使用（EC）DHE和PSK，在这种情况下将提供两个扩展。 

然后，服务器发送两条消息以建立服务器参数： 

EncryptedExtensions：对ClientHello扩展的响应，除了特定于单个证书的加密参数之外，不需要确定加密参数。 [第4.3.1节] 

CertificateRequest：如果是基于证书的客户端身份验证 
期望的，该证书的所需参数。 如果不需要客户端身份验证，则会省略此消息。 [第4.3.2节]最后，客户端和服务器交换认证消息。 每次需要基于证书的身份验证时，TLS都使用相同的消息集。 （基于PSK的身份验证是密钥交换的副作用。）具体来说：
 Rescorla标准轨道[第12页] 
 
 RFC 8446 TLS 2018年8月

证书：端点证书和任何每证书扩展。 如果未使用证书进行身份验证，则服务器将忽略此消息;如果服务器未发送CertificateRequest，则由客户端忽略此消息（从而指示客户端不应使用证书进行身份验证）。 请注意，如果正在使用原始公钥[RFC7250]或缓存的信息扩展[RFC7924] ，则此消息将不包含证书，而是包含与服务器的长期密钥对应的其他值。 [第4.4.2节] 

CertificateVerify：使用。整个握手的签名 
与证书消息中的公钥对应的私钥。 如果端点未通过证书进行身份验证，则会忽略此消息。 [第4.4.3节] 

完成：整个MAC（消息验证码） 
握手。 此消息提供密钥确认，将端点的标识绑定到交换的密钥，在PSK模式下也验证握手。 [第4.4.4节] 

收到服务器的消息后，客户端将响应其Authentication消息，即Certificate和CertificateVerify（如果请求）和Finished。 

此时，握手完成，客户端和服务器导出记录层所需的密钥材料，以交换通过认证加密保护的应用层数据。 除了第2.3节中的规定外，不得在发送完成消息之前发送应用程序数据。 请注意，虽然服务器可能会在接收客户端的身份验证消息之前发送应用程序数据，但此时发送的任何数据当然都会发送给未经身份验证的对等方。
 Rescorla标准轨道[第13页] 
 
 RFC 8446 TLS 2018年8月
 2.1 。  DHE共享不正确

如果客户端没有提供足够的“key_share”扩展（例如，它仅包括服务器不支持或不支持的DHE或ECDHE组），则服务器使用HelloRetryRequest更正不匹配，并且客户端需要使用适当的重新启动握手“key_share”扩展，如图2所示。如果不能协商通用的加密参数，服务器必须通过适当的警报中止握手。 

客户端服务器 
        客户问候
         + key_share -------->
                                                   HelloRetryRequest
                                 <-------- + key_share
        客户问候
         + key_share -------->
                                                        服务器问候
+ key_share 
{EncryptedExtensions} {CertificateRequest *} 
{证书*} 
{CertificateVerify *}
                                                          {}成品
                                 <-------- [申请资料*]
         {证书*}
         {CertificateVerify *}
         {完成} -------->
         [应用数据] <-------> [应用数据]

图2：完全握手的消息流 
参数不匹配 

注意：握手记录包含初始的ClientHello / HelloRetryRequest交换; 它不会被新的ClientHello重置。 

TLS还允许基本握手的几种优化变体，如以下部分所述。
 Rescorla Standards Track [第14页] 
 
 RFC 8446 TLS 2018年8月
 2.2 。  恢复和预共享密钥（PSK）

虽然可以在带外建立TLS PSK，但也可以在先前的连接中建立PSK，然后用于建立新连接（“会话恢复”或“恢复”与PSK）。 一旦握手完成，服务器就可以向客户端发送PSK标识，该标识对应于从初始握手得到的唯一密钥（参见第4.6.1节 ）。 然后，客户端可以在将来的握手中使用该PSK身份来协商相关PSK的使用。 如果服务器接受PSK，则新连接的安全上下文以加密方式绑定到原始连接，并且从初始握手派生的密钥用于引导加密状态而不是完全握手。 在TLS 1.2及更低版本中，此功能由“会话ID”和“会话票证” [RFC5077]提供 。 这两种机制都在TLS 1.3中被废弃。 

PSK可以与（EC）DHE密钥交换一起使用，以便与共享密钥一起提供前向保密，或者可以单独使用，代价是丢失应用数据的前向保密。 图3显示了一对握手，其中第一次握手建立PSK，第二次握手使用它：
 Rescorla Standards Track [第15页] 
 
 RFC 8446 TLS 2018年8月

客户端服务器 

初步握手：
          客户问候
           + key_share -------->
                                                          服务器问候
+ key_share 
{EncryptedExtensions} {CertificateRequest *} 
{证书*} 
{CertificateVerify *}
                                                            {}成品
                                     <-------- [申请资料*]
           {证书*}
           {CertificateVerify *}
           {完成} -------->
                                     <-------- [NewSessionTicket]
           [应用数据] <-------> [应用数据]


后续握手： 
客户问候
           + key_share *
           + pre_shared_key -------->
                                                          服务器问候
+ pre_shared_key 
+ key_share * 
{} EncryptedExtensions
                                                            {}成品
                                     <-------- [申请资料*]
           {完成} -------->
           [应用数据] <-------> [应用数据]

图3：恢复和PSK的消息流 

由于服务器通过PSK进行身份验证，因此它不会发送证书或CertificateVerify消息。 当客户端通过PSK提供恢复时，它应该还向服务器提供“key_share”扩展，以允许服务器拒绝恢复并在需要时回退到完全握手。 服务器以“pre_shared_key”扩展来响应以协商PSK密钥建立的使用，并且可以（如此处所示）以“key_share”扩展进行响应以进行（EC）DHE密钥建立，从而提供前向保密。 当PSK在带外配置时，PSK身份和要与PSK一起使用的KDF哈希算法也必须提供。 



 Rescorla标准轨道[第16页] 
 
 RFC 8446 TLS 2018年8月



注意：当使用带外预配置的预共享密钥时，关键考虑因素是在密钥生成期间使用足够的熵，如[RFC4086]中所述 。 从密码或其他低熵源获取共享密钥并不安全。 低熵密码或密码受基于PSK活页夹的字典攻击。 即使与Diffie-Hellman密钥建立一起使用，指定的PSK身份验证也不是基于密码的强身份验证密钥交换。 具体来说，它不会阻止可以观察到握手的攻击者对密码/预共享密钥执行暴力攻击。 
 2.3 。  0-RTT数据

当客户端和服务器共享PSK（从外部获得或通过先前的握手获得）时，TLS 1.3允许客户端在第一次飞行时发送数据（“早期数据”）。 客户端使用PSK对服务器进行身份验证并加密早期数据。 

如图4所示，0-RTT数据刚刚添加到第一次飞行中的1-RTT握手中。 握手的其余部分使用与具有PSK恢复的1-RTT握手相同的消息。 客户端服务器
 Rescorla标准轨道[第17页] 
 
 RFC 8446 TLS 2018年8月

ClientHello + early_data + key_share * + psk_key_exchange_modes
          + pre_shared_key
          （应用数据*）-------->
                                                         服务器问候
+ pre_shared_key 
+ key_share * 
{} EncryptedExtensions 
+ early_data *
                                                           {}成品
                                  <-------- [申请资料*]
          （EndOfEarlyData）
          {完成} -------->
          [应用数据] <-------> [应用数据]

+表示在中发送的值得注意的扩展名 
先前提到的消息。 

*表示并非总是发送的可选或依赖于情境的消息/扩展。 

（）表示使用密钥保护的消息 
派生自client_early_traffic_secret。 

{}表示使用密钥保护的消息 
派生自[ sender ] _handshake_traffic_secret。 

[]表示使用密钥保护的消息 
派生自[ sender ] _application_traffic_secret_N。 

图4：0-RTT握手的消息流
 Rescorla标准轨道[第18页] 
 
 RFC 8446 TLS 2018年8月
重要说明：0-RTT数据的安全属性弱于其他类型的TLS数据。 特别： 

1.此数据不是前向保密信息，因为它仅使用提供的PSK导出的密钥进行加密。 

2.连接之间不保证不重放。 通过服务器的Random值提供普通TLS 1.3 1-RTT数据的重放保护，但0-RTT数据不依赖于ServerHello，因此保证较弱。 如果数据通过TLS客户端身份验证或在应用程序协议内进行身份验证，则这尤其重要。 相同的警告适用于early_exporter_master_secret的任何使用。 

0-RTT数据不能在连接中复制（即，服务器不会为同一连接处理相同的数据两次），并且攻击者将无法使0-RTT数据看起来像1-RTT数据（因为它受不同的密钥保护）。 附录E.5包含潜在攻击的描述， 第8节描述了服务器可用于限制重放影响的机制。 


3 。 演讲语言 

本文档涉及外部表示中数据的格式。 将使用以下非常基本且稍微随意定义的表示语法。 
 3.1 。  基本块大小

明确指定所有数据项的表示。 基本数据块大小是一个字节（即8位）。 多字节数据项是从左到右，从上到下的字节串联。 从字节流中，通过以下方式形成一个多字节项（以下示例中的数字）（使用C表示法）： 
       value =（byte [0] << 8 *（n-1））|  （byte [1] << 8 *（n-2））|
               ...... | 字节[N-1];

多字节值的这种字节排序是常见的网络字节顺序或大端格式。
 Rescorla标准轨道[第19页] 
 
 RFC 8446 TLS 2018年8月
 3.2 。  杂

注释以“/ *”开头，以“* /”结尾。 

可选组件用“[[]]”（双括号）括起来表示。 

包含未解释数据的单字节实体属于不透明类型。 

现有类型T的类型别名T'由以下定义： 

T T'; 
 3.3 。  数字

基本数字数据类型是无符号字节（uint8）。 所有较大的数字数据类型都是按照3.1节所述连接的固定长度字节串构造的，并且也是无符号的。 以下数字类型是预定义的。 

uint8 uint16 [2]; uint8 uint24 [3]; uint8 uint32 [4]; uint8 uint64 [8]; 

所有值，在此处和规范中的其他地方，都以网络字节（big-endian）顺序传输; 由十六进制字节01 02 03 04表示的uint32等效于十进制值16909060。 
 3.4 。  矢量

向量（单维数组）是同类数据元素的流。 矢量的大小可以在文档时指定，或者在运行时之前不指定。 在任何一种情况下，长度都声明向量中的字节数，而不是元素数。 用于指定新类型T'的语法是T类型的固定长度向量 

T T'[n]; 

这里，T'占据数据流中的n个字节，其中n是T大小的倍数。矢量的长度不包括在编码流中。 在下面的示例中，Datum被定义为协议不解释的三个连续字节，而Data是三个连续的Datum，总共消耗9个字节。
 Rescorla标准轨道[第20页] 
 
 RFC 8446 TLS 2018年8月

不透明的基准面[3]; / *三个未解释的字节* / Datum Data [9]; / *三个连续的3字节向量* / 

可变长度向量是通过使用符号<floor..ceiling>指定合法长度的子范围来定义的。 对它们进行编码时，实际长度位于字节流中向量的内容之前。 长度将采用数字的形式，消耗尽可能多的字节数来保存向量的指定最大（天花板）长度。 实际长度字段为零的可变长度矢量被称为空矢量。 

T T'<floor..ceiling>; 

在以下示例中，“mandatory”是一个向量，必须包含300到400个字节的opaque类型。 它永远不会是空的。 实际长度字段消耗两个字节，即uint16，足以表示值400（参见第3.3节 ）。 类似地，“更长”可以表示多达800字节的数据或400 uint16元素，并且它可以是空的。 它的编码将包括一个前置于向量的两字节实际长度字段。 编码矢量的长度必须是单个元素长度的精确倍数（例如，uint16的17字节矢量将是非法的）。 

不透明强制<300..400>; 
/ * length字段是两个字节，不能为空* ​​/ 
uint16更长<0..800>; 
/ * 0到400个16位无符号整数* / 
 3.5 。  Enumerateds

可以使用称为“enum”或“enumerated”的其他稀疏数据类型。 每个定义都是不同的类型。 只能分配或比较相同类型的枚举。 必须为枚举的每个元素分配一个值，如以下示例所示。 由于枚举的元素没有排序，因此可以按任何顺序为它们分配任何唯一值。 

枚举{e1（v1），e2（v2），...，en（vn）[[，（n）]]} Te; 

未来对协议的扩展或添加可以定义新值。 实现需要能够解析和忽略未知值，除非字段的定义另有说明。 枚举在字节流中占用的空间与其最大定义的序数值一样多。 以下定义将导致一个字节用于携带Color类型的字段。 




 Rescorla标准轨道[第21页] 
 
 RFC 8446 TLS 2018年8月



枚举{red（3），blue（5），white（7）}颜色; 

可以选择指定一个没有相关标签的值来强制宽度定义而不定义多余的元素。 

在以下示例中，Taste将在数据流中消耗两个字节，但在当前版本的协议中只能采用值1,2或4。 

enum {sweet（1），sour（2），bitter（4），（32000）}味道; 

枚举元素的名称在定义的类型中作用域。 在第一个示例中，枚举的第二个元素的完全限定引用是Color.blue。 如果指定的目标明确规定，则不需要这种资格。 

颜色= Color.blue; / *过度指定，合法* /颜色=蓝色; / *正确，输入隐式* / 

分配给枚举的名称不必是唯一的。 数值可以描述相同名称适用的范围。 该值包括该范围内的最小和最大包含值，以两个句点字符分隔。 这主要用于保留空间区域。 

enum {sad（0），meh（1..254），happy（255）}心情; 
 3.6 。  构造类型

为方便起见，可以从原始类型构造结构类型。 每个规范都声明一种新的唯一类型。 用于定义的语法非常类似于C. 

struct { 
T1 f1; T2 f2; ... Tn fn; 
} T; 

使用标准向量语法允许固定长度和可变长度向量字段。 变体示例（ 第3.8节 ）中的结构V1和V2证明了这一点。 结构中的字段可以使用类型的名称进行限定，其语法与枚举可用的语法非常相似。 例如，T.f2指的是前一个声明的第二个字段。 


 Rescorla标准轨道[第22页] 
 
 RFC 8446 TLS 2018年8月



 3.7 。  常量

可以使用“=”为字段和变量分配固定值，如下所示： 

struct { 
T1 f1 = 8; / * T.f1必须始终为8 * / T2 f2; 
} T; 
 3.8 。  变种

定义的结构可能具有基于环境中可用的一些知识的变体。 选择器必须是枚举类型，用于定义结构定义的可能变体。 select（下方）的每个臂指定该变体字段的类型和可选字段标签。 在运行时选择变体的机制不是由表示语言规定的。 

struct { 
T1 f1; T2 f2; .... Tn fn; select（E）{case e1：Te1 [[fe1]]; 案例e2：Te2 [[fe2]]; ....案例en：十[[fen]]; 
}; 
电视;
 Rescorla标准轨道[第23页] 
 
 RFC 8446 TLS 2018年8月
例如： 

枚举{apple（0），orange（1）} VariantTag; 

struct {uint16 number; opaque string <0..10>; / *可变长度* /} V1; 

struct {uint32 number; 不透明的字符串[10]; / *固定长度* /} V2; 

struct {VariantTag type; select（VariantRecord.type）{case apple：V1; 案例橙：V2; 
}; 
VariantRecord; 

4 。 握手协议 

握手协议用于协商连接的安全参数。 握手消息被提供给TLS记录层，其中它们被封装在一个或多个TLSPlaintext或TLSCiphertext结构中，这些结构按照当前活动连接状态的指定进行处理和发送。
 Rescorla标准轨道[第24页] 
 
 RFC 8446 TLS 2018年8月
枚举{ 
client_hello（1），server_hello（2），new_session_ticket（4），end_of_early_data（5），encrypted_extensions（8），certificate（11），certificate_request（13），certificate_verify（15），finished（20），key_update（24）， message_hash（254），（255）} HandshakeType; 

struct {HandshakeType msg_type; / *握手类型* / uint24长度; / *消息中的剩余字节* /
           select（Handshake.msg_type）{
               case client_hello：ClientHello;
               case server_hello：ServerHello;
               case end_of_early_data：EndOfEarlyData;
case encrypted_extensions：EncryptedExtensions; case certificate_request：CertificateRequest; 案件证明：证书; case certificate_verify：CertificateVerify; 案件结束：完成; case new_session_ticket：NewSessionTicket; case key_update：KeyUpdate; 
}; 
握手; 

协议消息必须按照第4.4.1节中定义的顺序发送，并在第2节的图中显示。 以意外顺序接收握手消息的对等方必须使用“unexpected_message”警报中止握手。 

IANA分配了新的握手消息类型，如第11节所述。 
 4.1 。  密钥交换消息

密钥交换消息用于确定客户端和服务器的安全性能并建立共享秘密，包括用于保护握手和数据的其余部分的流量密钥。 




 Rescorla标准轨道[第25页] 
 
 RFC 8446 TLS 2018年8月


 4.1.1 。  密码谈判

在TLS中，加密协商由客户端在其ClientHello中提供以下四组选项来进行： 

- 密码套件列表，表示客户端支持的AEAD算法/ HKDF哈希对。 

- “supported_groups”（ 第4.2.7节 ）扩展，指示客户端支持的（EC）DHE组和“key_share”（ 第4.2.8节 ）扩展，其中包含部分或全部这些组的（EC）DHE共享。 

- “signature_algorithms”（ 第4.2.3节 ）扩展，指示客户端可以接受的签名算法。 还可以添加“signature_algorithms_cert”扩展（ 第4.2.3节 ）以指示特定于证书的签名算法。 

- “pre_shared_key”（ 第4.2.11节 ）扩展，其中包含客户端已知的对称密钥标识列表和“psk_key_exchange_modes”（ 第4.2.9节 ）扩展，该扩展指示可与PSK一起使用的密钥交换模式。 

如果服务器没有选择PSK，则前三个选项完全正交：服务器独立选择密码套件，（EC）DHE组和用于密钥建立的密钥共享，以及用于验证的签名算法/证书对本身对客户。 如果收到的“supported_groups”与服务器支持的组之间没有重叠，则服务器必须通过“handshake_failure”或“insufficient_security”警报中止握手。 

如果服务器选择PSK，那么它还必须从客户端的“psk_key_exchange_modes”扩展指示的集合中选择密钥建立模式（目前，仅PSK或（EC）DHE）。 请注意，如果PSK可以在没有（EC）DHE的情况下使用，那么“supported_groups”参数中的非重叠不一定是致命的，因为它是在前一段中讨论的非PSK情况中。 

如果服务器选择（EC）DHE组并且客户端未在初始ClientHello中提供兼容的“key_share”扩展，则服务器必须使用HelloRetryRequest（ 第4.1.4节 ）消息进行响应。 如果服务器成功选择参数并且不需要HelloRetryRequest，它将在ServerHello中指示所选参数，如下所示：
 Rescorla标准轨道[第26页] 
 
 RFC 8446 TLS 2018年8月

- 如果正在使用PSK，则服务器将发送指示所选密钥的“pre_shared_key”扩展名。 

- 当（EC）DHE正在使用时，服务器还将提供“key_share”扩展名。 如果未使用PSK，则始终使用（EC）DHE和基于证书的身份验证。 

- 通过证书进行身份验证时，服务器将发送证书（ 第4.4.2节 ）和CertificateVerify（ 第4.4.3节 ）消息。 在本文档定义的TLS 1.3中，始终使用PSK或证书，但不能同时使用两者。 未来的文件可能会定义如何一起使用它们。 

如果服务器无法协商一组受支持的参数（即，客户端和服务器参数之间没有重叠），它必须使用“handshake_failure”或“insufficient_security”致命警报中止握手（参见第6节 ）。 
 4.1.2 。  客户你好

当客户端首次连接到服务器时，需要将ClientHello作为其第一个TLS消息发送。 当服务器使用HelloRetryRequest响应其ClientHello时，客户端也将发送ClientHello。 在这种情况下，客户端必须发送相同的ClientHello而不进行修改，除非如下： 

- 如果在HelloRetryRequest中提供了“key_share”扩展名，则使用包含指定组中的单个KeyShareEntry的列表替换共享列表。 

- 删除“early_data”扩展（ 第4.2.10节 ）（如果存在）。 HelloRetryRequest后不允许早期数据。 

- 如果在HelloRetryRequest中提供了一个“cookie”扩展，则包括“cookie”扩展。
 Rescorla Standards Track [第27页] 
 
 RFC 8446 TLS 2018年8月
- 通过重新计算“obfuscated_ticket_age”和绑定器值以及（可选）删除与服务器指示的密码套件不兼容的任何PSK，更新“pre_shared_key”扩展（如果存在）。 

- 可选择添加，删除或更改“填充”扩展名[RFC7685]的长度。 

- 未来定义并存在于HelloRetryRequest中的扩展可能允许的其他修改。 

因为TLS 1.3禁止重新协商，如果服务器已协商TLS 1.3并在任何其他时间收到ClientHello，它必须使用“unexpected_message”警报终止连接。 

如果服务器与先前版本的TLS建立TLS连接并在重新协商中收到TLS 1.3 ClientHello，则它必须保留先前的协议版本。 特别是，它不能协商TLS 1.3。 

此消息的结构： 

uint16 ProtocolVersion; 不透明随机[32]; 

uint8 CipherSuite [2]; / *加密套件选择器* / 

struct {ProtocolVersion legacy_version = 0x0303; / * TLS v1.2 * /随机随机; opaque legacy_session_id <0..32>; CipherSuite cipher_suites <2..2 ^ 16-2>; opaque legacy_compression_methods <1..2 ^ 8-1>; 扩展名扩展名<8..2 ^ 16-1>; 
ClientHello;
 Rescorla标准轨道[第28页] 
 
 RFC 8446 TLS 2018年8月
legacy_version：在以前版本的TLS中，此字段用于 
版本协商并表示客户端支持的最高版本号。 经验表明，许多服务器没有正确实现版本协商，导致“版本不容忍”，其中服务器拒绝版本号高于其支持的其他可接受的ClientHello。 在TLS 1.3中，客户端在“supported_versions”扩展（ 第4.2.1节 ）中指示其版本首选项，并且legacy_version字段必须设置为0x0303，这是TLS 1.2的版本号。 TLS 1.3 ClientHellos被识别为具有0x0303的legacy_version和supported_versions扩展，其中0x0304作为其中指示的最高版本。 （有关向后兼容性的详细信息，请参阅附录D. ） 

random：由安全随机数生成器生成的32个字节。 看到 
附录C了解更多信息。 

legacy_session_id：TLS 1.3支持之前的TLS版本 
“会话恢复”功能已与此版本中的预共享密钥合并（请参阅第2.2节 ）。 具有由TLS 1.3之前的服务器设置的缓存会话ID的客户端应该将该字段设置为该值。 在兼容模式下（见附录D.4 ），该字段必须是非空的，因此不提供预TLS 1.3会话的客户端必须生成一个新的32字节值。 这个值不必是随机的，但应该是不可预测的，以避免实现固定在特定值（也称为骨化）。 否则，必须将其设置为零长度向量（即，零值单字节长度字段）。 

cipher_suites：支持的对称密码选项列表 
客户端，特别是记录保护算法（包括密钥长度）和与HKDF一起使用的哈希，按客户端偏好的降序排列。 值在附录B.4中定义。 如果列表包含服务器无法识别，支持或希望使用的密码套件，则服务器必须忽略这些密码套件并像往常一样处理其余密码套件。 如果客户端正在尝试PSK密钥建立，则它应该通告至少一个密码套件，该密码套件指示与PSK相关联的哈希。
 Rescorla标准轨道[第29页] 
 
 RFC 8446 TLS 2018年8月
legacy_compression_methods：支持1.3之前的TLS版本 
使用此字段中发送的受支持压缩方法列表进行压缩。 对于每个TLS 1.3 ClientHello，此向量必须包含一个字节，设置为零，这对应于先前版本的TLS中的“空”压缩方法。 如果在此字段中收到TLS 1.3 ClientHello以及任何其他值，则服务器必须使用“illegal_parameter”警报中止握手。 请注意，TLS 1.3服务器可能会收到包含其他压缩方法的TLS 1.2或之前的ClientHellos，并且（如果协商此类先前版本）必须遵循相应的TLS先前版本的过程。 

扩展：客户端通过服务器请求扩展功能 
在扩展字段中发送数据。 实际的“扩展”格式在4.2节中定义。 在TLS 1.3中，必须使用某些扩展，因为功能已转移到扩展中以保持ClientHello与先前版本的TLS的兼容性。 服务器必须忽略无法识别的扩展。 

所有版本的TLS都允许扩展字段可选地遵循compression_methods字段。 TLS 1.3 ClientHello消息始终包含扩展（最低限度为“supported_versions”，否则，它们将被解释为TLS 1.2 ClientHello消息）。 但是，TLS 1.3服务器可能会收到ClientHello消息而没有来自先前版本的TLS的扩展字段。 可以通过确定ClientHello末尾的compression_methods字段后面是否有字节来检测扩展的存在。 请注意，这种检测可选数据的方法与具有可变长度字段的常规TLS方法不同，但它用于在定义扩展之前与TLS兼容。 TLS 1.3服务器需要首先执行此检查，并且仅在存在“supported_versions”扩展时才尝试协商TLS 1.3。 如果在1.3之前协商一个TLS版本，服务器必须检查该消息是否在legacy_compression_methods之后不包含数据，或者它包含一个没有数据的有效扩展块。 如果没有，那么它必须通过“decode_error”警报中止握手。 

如果客户端使用扩展请求其他功能，并且服务器不提供此功能，则客户端可以中止握手。 

发送ClientHello消息后，客户端等待ServerHello或HelloRetryRequest消息。 如果正在使用早期数据，则客户端可以在等待下一个握手消息的同时发送早期应用数据（ 第2.3节 ）。 




 Rescorla标准轨道[第30页] 
 
 RFC 8446 TLS 2018年8月


 4.1.3 。  服务器你好

如果能够根据ClientHello协商一组可接受的握手参数，则服务器将发送此消息以响应ClientHello消息以继续握手。 

此消息的结构： 

struct { 
ProtocolVersion legacy_version = 0x0303; / * TLS v1.2 * /随机随机; opaque legacy_session_id_echo <0..32>; CipherSuite cipher_suite; uint8 legacy_compression_method = 0; 扩展名扩展名<6..2 ^ 16-1>; 
} ServerHello; 

legacy_version：在以前版本的TLS中，此字段用于 
版本协商并表示连接的选定版本号。 不幸的是，一些中间盒在呈现新值时会失败。 在TLS 1.3中，TLS服务器使用“supported_versions”扩展（ 第4.2.1节 ）指示其版本，并且legacy_version字段必须设置为0x0303，这是TLS 1.2的版本号。 （有关向后兼容性的详细信息，请参阅附录D. ） 

random：由安全随机数生成器生成的32个字节。 看到 
附录C了解更多信息。 如果协商TLS 1.2或TLS 1.1，则必须覆盖最后8个字节，如下所述，但其余字节必须是随机的。 该结构由服务器生成，必须独立于ClientHello.random生成。 

legacy_session_id_echo：客户端的内容 
legacy_session_id字段。 请注意，即使客户端的值对应于服务器已选择不恢复的缓存的TLS 1.3之前的会话，也会回显此字段。 接收到与ClientHello中发送的内容不匹配的legacy_session_id_echo字段的客户端必须使用“illegal_parameter”警报中止握手。 

cipher_suite：服务器从中选择的单个密码套件 
ClientHello.cipher_suites中的列表。 接收未提供的密码套件的客户端务必使用“illegal_parameter”警报中止握手。 

legacy_compression_method：必须拥有的单个字节 
值0。 


 Rescorla标准轨道[第31页] 
 
 RFC 8446 TLS 2018年8月


扩展：扩展列表。 ServerHello必须只包括 
建立加密上下文和协商协议版本所需的扩展。 所有TLS 1.3 ServerHello消息必须包含“supported_versions”扩展名。 当前的ServerHello消息还包含“pre_shared_key”扩展名或“key_share”扩展名，或两者兼有（当使用带有（EC）DHE密钥建立的PSK时）。 其他扩展（参见第4.2节 ）在EncryptedExtensions消息中单独发送。 

出于向后兼容中间件的原因（参见附录D.4 ），HelloRetryRequest消息使用与ServerHello相同的结构，但将Random设置为“HelloRetryRequest”的SHA-256的特殊值： 

CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91 C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C 

在收到类型为server_hello的消息后，实现必须首先检查Random值，如果它匹配该值，则按照4.1.4节中的描述进行处理。 

TLS 1.3具有嵌入在服务器随机值中的降级保护机制。 响应ClientHello协商TLS 1.2或更低版本的TLS 1.3服务器必须特别在其ServerHello中设置其Random值的最后8个字节。 

如果协商TLS 1.2，TLS 1.3服务器必须将其Random值的最后8个字节设置为字节： 

44 4F 57 4E 47 52 44 01 

如果协商TLS 1.1或更低版本，TLS 1.3服务器必须，并且TLS 1.2服务器应该将其ServerHello.Random值的最后8个字节设置为字节： 

44 4F 57 4E 47 52 44 00 

接收指示TLS 1.2或更低的ServerHello的TLS 1.3客户端必须检查最后8个字节是否不等于这些值中的任何一个。 如果ServerHello指示TLS 1.1或更低，则TLS 1.2客户端还应检查最后8个字节是否不等于第二个值。 如果找到匹配项，客户端必须通过“illegal_parameter”警报中止握手。 此机制提供有限的保护，防止降级攻击超过完成交换所提供的范围：因为ServerKeyExchange（TLS 1.2及更低版本中存在的消息）包含两个随机值的签名，因此主动攻击者无法修改只要使用短暂密码，就可以不检测随机值。 使用静态RSA时，它不提供降级保护。 


 Rescorla Standards Track [第32页] 
 
 RFC 8446 TLS 2018年8月



注意：这是对[RFC5246]的更改，因此在实践中，许多TLS 1.2客户端和服务器的行为不会如上所述。 

传统TLS客户端使用TLS 1.2或更早版本执行重新协商，并在重新协商期间接收TLS 1.3 ServerHello，必须使用“protocol_version”警报中止握手。 请注意，在协商TLS 1.3时无法进行重新协商。 
 4.1.4 。  您好重试请求

如果客户端能够找到一组可接受的参数但ClientHello不包含足够的信息来继续握手，则服务器将发送此消息以响应ClientHello消息。 如4.1.3节所述，HelloRetryRequest具有与ServerHello消息相同的格式，legacy_version，legacy_session_id_echo，cipher_suite和legacy_compression_method字段具有相同的含义。 但是，为方便起见，我们在整个文档中讨论“HelloRetryRequest”，就好像它是一个独特的消息。 

服务器的扩展必须包含“supported_versions”。 此外，它应该包含客户端生成正确的ClientHello对所需的最小扩展集。 与ServerHello一样，HelloRetryRequest绝不能包含客户端在其ClientHello中首先提供的任何扩展，除了可选的“cookie”（参见第4.2.2节 ）扩展。 

收到HelloRetryRequest后，客户端必须检查第4.1.3节中指定的legacy_version，legacy_session_id_echo，cipher_suite和legacy_compression_method，然后处理扩展，从使用“supported_versions”确定版本开始。 如果HelloRetryRequest不会导致ClientHello发生任何变化，客户端必须使用“illegal_parameter”警报中止握手。 如果客户端在同一连接中接收到第二个HelloRetryRequest（即，ClientHello本身响应HelloRetryRequest），它必须以“unexpected_message”警报中止握手。 否则，客户端必须处理HelloRetryRequest中的所有扩展并发送第二个更新的ClientHello。 本规范中定义的HelloRetryRequest扩展是：
 Rescorla Standards Track [第33页] 
 
 RFC 8446 TLS 2018年8月

- supported_versions（参见第4.2.1节 ） 

- cookie（参见第4.2.2节 ） 

- key_share（参见第4.2.8节 ） 

接收未提供的密码套件的客户端必须中止握手。 服务器必须确保在接收到符合更新的ClientHello时协商相同的密码套件（如果服务器选择密码套件作为协商的第一步，那么这将自动发生）。 收到ServerHello后，客户端必须检查ServerHello中提供的密码套件是否与HelloRetryRequest中的密码套件相同，否则将使用“illegal_parameter”警报中止握手。 

此外，在其更新的ClientHello中，客户端不应提供与除选定密码套件之外的散列相关联的任何预共享密钥。 这允许客户端避免在第二个ClientHello中计算多个哈希的部分哈希转录本。 

HelloRetryRequest“supported_versions”扩展中的selected_version值必须保留在ServerHello中，如果值发生变化，客户端必须使用“illegal_parameter”警报中止握手。
 Rescorla Standards Track [第34页] 
 
 RFC 8446 TLS 2018年8月
 4.2 。  扩展

许多TLS消息包含标记长度值编码的扩展结构。 

struct { 
ExtensionType extension_type; opaque extension_data <0..2 ^ 16-1>; } 延期; 

枚举{server_name（0），/ * RFC 6066 * / max_fragment_length（1），/ * RFC 6066 * / status_request（5），/ * RFC 6066 * / supported_groups（10），/ * RFC 8422,7919 * / signature_algorithms（ 13），/ * RFC 8446 * / use_srtp（14），/ * RFC 5764 * / heartbeat（15），/ * RFC 6520 * / application_layer_protocol_negotiation（16），/ * RFC 7301 * / signed_certificate_timestamp（18），/ * RFC 6962 * / client_certificate_type（19），/ * RFC 7250 * / server_certificate_type（20），/ * RFC 7250 * / padding（21），/ * RFC 7685 * / pre_shared_key（41），/ * RFC 8446 * / early_data（42 ），/ * RFC 8446 * / supported_versions（43），/ * RFC 8446 * / cookie（44），/ * RFC 8446 * / psk_key_exchange_modes（45），/ * RFC 8446 * / certificate_authorities（47），/ * RFC 8446 * / oid_filters（48），/ * RFC 8446 * / post_handshake_auth（49），/ * RFC 8446 * / signature_algorithms_cert（50），/ * RFC 8446 * / key_share（51），/ * RFC 8446 * /（65535） 
} ExtensionType;
 Rescorla标准轨道[第35页] 
   RFC 8446 TLS 2018年8月 
这里： 

- “extension_type”标识特定的扩展类型。 

- “extension_data”包含特定扩展类型的特定信息。 

扩展类型列表由IANA维护，如第11节所述。 

扩展通常以请求/响应方式构造，但是一些扩展只是没有相应响应的指示。 客户端在ClientHello消息中发送其扩展请求，服务器在ServerHello，EncryptedExtensions，HelloRetryRequest和Certificate消息中发送其扩展响应。 服务器在CertificateRequest消息中发送扩展请求，客户端可以使用Certificate消息来响应该消息。 服务器也可以在NewSessionTicket中发送未经请求的扩展，但客户端不会直接响应这些扩展。 

如果远程端点没有发送相应的扩展请求，则实现绝不能发送扩展响应，但HelloRetryRequest中的“cookie”扩展除外。 收到这样的扩展后，端点必须通过“unsupported_extension”警报中止握手。 

下表使用以下符号表示可能出现给定扩展名的消息：CH（ClientHello），SH（ServerHello），EE（加密扩展），CT（证书），CR（CertificateRequest），NST（NewSessionTicket）和HRR （HelloRetryRequest）。 如果某个实现接收到它识别的扩展并且没有为它出现的消息指定，那么它必须使用“illegal_parameter”警报中止握手。
 Rescorla标准轨道[第36页] 
 
 RFC 8446 TLS 2018年8月
    + ------------------------------------------------- -  + ------------- +
    | 扩展|  TLS 1.3 |
    + ------------------------------------------------- -  + ------------- +
    |  server_name [ RFC6066 ] |  CH，EE |
    |  |  |
    |  max_fragment_length [ RFC6066 ] |  CH，EE |
    |  |  |
    |  status_request [ RFC6066 ] |  CH，CR，CT |
    |  |  |
    |  supported_groups [ RFC7919 ] |  CH，EE |
    |  |  |
    |  signature_algorithms（ RFC 8446 ）|  CH，CR |
    |  |  |
    |  use_srtp [ RFC5764 ] |  CH，EE |
    |  |  |
    | 心跳[ RFC6520 ] |  CH，EE |
    |  |  |
    |  application_layer_protocol_negotiation [ RFC7301 ] |  CH，EE |
    |  |  |
    |  signed_certificate_timestamp [ RFC6962 ] |  CH，CR，CT |
    |  |  |
    |  client_certificate_type [ RFC7250 ] |  CH，EE |
    |  |  |
    |  server_certificate_type [ RFC7250 ] |  CH，EE |
    |  |  |
    | 填充[ RFC7685 ] |  CH |
    |  |  |
    |  key_share（ RFC 8446 ）|  CH，SH，HRR |
    |  |  |
    |  pre_shared_key（ RFC 8446 ）|  CH，SH |
    |  |  |
    |  psk_key_exchange_modes（ RFC 8446 ）|  CH |
    |  |  |
    |  early_data（ RFC 8446 ）|  CH，EE，NST |
    |  |  |
    |  cookie（ RFC 8446 ）|  CH，HRR |
    |  |  |
    |  supported_versions（ RFC 8446 ）|  CH，SH，HRR |
    |  |  |
    |  certificate_authorities（ RFC 8446 ）|  CH，CR |
    |  |  |
    |  oid_filters（ RFC 8446 ）|  CR |
    |  |  |
    |  post_handshake_auth（ RFC 8446 ）|  CH |
    |  |  |
    |  signature_algorithms_cert（ RFC 8446 ）|  CH，CR |
    + ------------------------------------------------- -  + ------------- +




 Rescorla标准轨道[第37页] 
 
 RFC 8446 TLS 2018年8月


当存在多个不同类型的扩展时，扩展可以按任何顺序出现，但“pre_shared_key”（ 第4.2.11节 ）除外，它必须是ClientHello中的最后一个扩展（但可以出现在ServerHello扩展块中的任何位置） 。 在给定的扩展块中，不得有多个相同类型的扩展。 

在TLS 1.3中，与TLS 1.2不同，即使处于恢复-PSK模式，也会针对每次握手协商扩展。 但是，0-RTT参数是先前握手中协商的参数; 不匹配可能需要拒绝0-RTT（参见第4.2.10节 ）。 

在新协议和现有功能之间，此协议中可能会发生微妙（而不是那么微妙）的交互，这可能会导致整体安全性显着降低。 在设计新扩展时，应考虑以下注意事项： 

- 服务器不同意扩展的一些情况是错误条件（例如，握手不能继续），并且一些仅仅是拒绝支持特定功能。 通常，错误警报应该用于前者，而服务器扩展响应中的字段应该用于后者。 

- 扩展应尽可能设计为防止任何通过操纵握手消息强制使用（或不使用）特定功能的攻击。 无论该功能是否被认为会导致安全问题，都应遵循此原则。 通常，扩展字段包含在Finished消息散列的输入中这一事实就足够了，但是当扩展改变了握手阶段发送的消息的含义时，需要格外小心。 设计人员和实现者应该意识到，在握手经过身份验证之前，主动攻击者可以修改消息并插入，删除或替换扩展。
 Rescorla标准轨道[第38页] 
 
 RFC 8446 TLS 2018年8月
 4.2.1 。  支持的版本

struct { 
select（Handshake.msg_type）{ 
case client_hello： 
ProtocolVersion版本<2..254>; 

case server_hello：/ *和HelloRetryRequest * / 
ProtocolVersion selected_version; 
}; 
} SupportedVersions; 

客户端使用“supported_versions”扩展来指示它支持的TLS版本以及服务器指示它使用的版本。 该扩展包含优先顺序的受支持版本列表，首先是最优选的版本。 本规范的实现必须在ClientHello中发送此扩展，其中包含它们准备协商的所有TLS版本（对于此规范，这意味着最低为0x0304，但如果允许协商先前版本的TLS，则它们也必须存在）。 

如果此扩展不存在，那么符合此规范并且也支持TLS 1.2的服务器必须按照[RFC5246]中的规定协商TLS 1.2或更早版本 ，即使ClientHello.legacy_version为0x0304或更高版本。 服务器可以在收到带有legacy_version 0x0304或更高版本的ClientHello时中止握手。 

如果ClientHello中存在此扩展，则服务器不得使用ClientHello.legacy_version值进行版本协商，并且必须仅使用“supported_versions”扩展来确定客户端首选项。 服务器必须只选择该扩展中存在的TLS版本，并且必须忽略该扩展中存在的任何未知版本。 请注意，如果一方支持稀疏范围，则此机制可以在TLS 1.2之前协商版本。 选择支持TLS早期版本的TLS 1.3的实现应该支持TLS 1.2。 服务器必须准备好接收包含此扩展但在版本列表中不包含0x0304的ClientHellos。 

在TLS 1.3之前协商TLS版本的服务器必须设置ServerHello.version并且不得发送“supported_versions”扩展。 协商TLS 1.3的服务器必须通过发送包含所选版本值（0x0304）的“supported_versions”扩展来响应。 它必须将ServerHello.legacy_version字段设置为0x0303（TLS 1.2）。 客户端必须在处理ServerHello的其余部分之前检查此扩展（尽管他们必须解析ServerHello才能读取扩展）。 如果存在此扩展，客户端必须忽略ServerHello.legacy_version值并且必须仅使用“supported_versions”扩展来确定所选版本。 如果ServerHello中的“supported_versions”扩展包含客户端未提供的版本或包含TLS 1.3之前的版本，则客户端必须使用“illegal_parameter”警报中止握手。 


 Rescorla标准轨道[第39页] 
 
 RFC 8446 TLS 2018年8月



 4.2.2 。  曲奇饼

struct { 
opaque cookie <1..2 ^ 16-1>; 
} 曲奇饼; 

Cookie主要用于两个目的： 

- 允许服务器强制客户端在其明显的网络地址上演示可达性（从而提供DoS保护措施）。 这对于非面向连接的传输非常有用（有关此示例，请参阅[RFC6347] ）。 

- 允许服务器将状态卸载到客户端，从而允许它发送HelloRetryRequest而不存储任何状态。 服务器可以通过将ClientHello的哈希值存储在HelloRetryRequest cookie中（使用一些合适的完整性保护算法进行保护）来完成此操作。 

发送HelloRetryRequest时，服务器可以向客户端提供“cookie”扩展（这是通常规则的例外，即可以发送的唯一扩展是ClientHello中出现的扩展）。 发送新的ClientHello时，客户端必须将HelloRetryRequest中收到的扩展内容复制到新ClientHello中的“cookie”扩展名中。 客户端在后续连接中不得在其初始ClientHello中使用cookie。 

当服务器无状态运行时，它可能会在第一个和第二个ClientHello之间收到类型为change_cipher_spec的不受保护的记录（参见第5节 ）。 由于服务器没有存储任何状态，因此它看起来好像是第一个要接收的消息。 无状态运行的服务器必须忽略这些记录。
 Rescorla标准轨道[第40页] 
 
 RFC 8446 TLS 2018年8月
 4.2.3 。  签名算法

TLS 1.3提供了两个扩展，用于指示可以在数字签名中使用哪些签名算法。 “signature_algorithms_cert”扩展名适用于证书中的签名，最初出现在TLS 1.2中的“signature_algorithms”扩展名适用于CertificateVerify消息中的签名。 证书中的密钥也必须是与它们一起使用的签名算法的适当类型。 这是RSA密钥和PSS签名的特殊问题，如下所述。 如果不存在“signature_algorithms_cert”扩展名，则“signature_algorithms”扩展名也适用于证书中出现的签名。 希望服务器通过证书进行身份验证的客户端必须发送“signature_algorithms”扩展。 如果服务器通过证书进行身份验证，并且客户端没有发送“signature_algorithms”扩展，那么服务器必须使用“missing_extension”警报中止握手（参见第9.2节 ）。 

添加了“signature_algorithms_cert”扩展，以允许支持不同证书集的实现，并在TLS本身中明确表示其功能。 TLS 1.2实现应该也应该处理这个扩展。 在两种情况下具有相同策略的实现可以省略“signature_algorithms_cert”扩展。 这些扩展的“extension_data”字段包含SignatureSchemeList值：
 Rescorla Standards Track [第41页] 
 
 RFC 8446 TLS 2018年8月

枚举{ 
/ * RSASSA-PKCS1-v1_5算法* / rsa_pkcs1_sha256（0x0401），rsa_pkcs1_sha384（0x0501），rsa_pkcs1_sha512（0x0601）， 

/ * ECDSA算法* / ecdsa_secp256r1_sha256（0x0403），ecdsa_secp384r1_sha384（0x0503），ecdsa_secp521r1_sha512（0x0603）， 

/ * RSASSA-PSS算法，公钥OID rsaEncryption * / rsa_pss_rsae_sha256（0x0804），rsa_pss_rsae_sha384（0x0805），rsa_pss_rsae_sha512（0x0806）， 

/ * EdDSA算法* / ed25519（0x0807），ed448（0x0808）， 

/ * RSASSA-PSS算法，公钥OID RSASSA-PSS * / rsa_pss_pss_sha256（0x0809），rsa_pss_pss_sha384（0x080a），rsa_pss_pss_sha512（0x080b）， 

/ *传统算法* / rsa_pkcs1_sha1（0x0201），ecdsa_sha1（0x0203）， 

/ *保留代码点* / private_use（0xFE00..0xFFFF），（0xFFFF）} SignatureScheme; 

struct { 
SignatureScheme supported_signature_algorithms <2..2 ^ 16-2>; 
} SignatureSchemeList; 

注意：此枚举名为“SignatureScheme”，因为在TLS 1.2中已经有一个“SignatureAlgorithm”类型，这将替换它。 我们在整个文本中使用术语“签名算法”。 每个SignatureScheme值列出客户端愿意验证的单个签名算法。 值以优先级的降序表示。 请注意，签名算法将任意长度的消息作为输入，而不是摘要。 传统上对摘要起作用的算法应该在TLS中定义，首先使用指定的散列算法对输入进行散列，然后照常进行。 上面列出的代码点组具有以下含义：
 Rescorla标准轨道[第42页] 
 
 RFC 8446 TLS 2018年8月

RSASSA-PKCS1-v1_5算法：表示使用RSASSA-PKCS1-v1_5 [RFC8017]的签名算法，其具有[SHS]中定义的相应散列算法。 这些值仅指出现在证书中的签名（参见第4.4.2.2节 ），并且未定义用于签名的TLS握手消息，尽管它们可能出现在“signature_algorithms”和“signature_algorithms_cert”中，以便与TLS 1.2向后兼容。 

ECDSA算法：表示使用ECDSA的签名算法 
[ECDSA] ，ANSI X9.62 [ECDSA]和FIPS 186-4 [DSS]中定义的相应曲线，以及[SHS]中定义的相应散列算法。 签名表示为DER编码的[X690] ECDSA-Sig-Value结构。 

RSASSA-PSS RSAE算法：表示使用的签名算法 
具有掩码生成功能的RSASSA-PSS [RFC8017] 1.掩码生成函数中使用的摘要和被签名的摘要都是[SHS]中定义的相应散列算法。 Salt的长度必须等于摘要算法的输出长度。 如果公钥在X.509证书中携带，它必须使用rsaEncryption OID [RFC5280] 。 

EdDSA算法：表示使用EdDSA的签名算法 
在[RFC8032]或其后续版本中定义。 请注意，这些算法对应于“PureEdDSA”算法，而不是“prehash”变体。 

RSASSA-PSS PSS算法：表示使用的签名算法 
具有掩码生成功能的RSASSA-PSS [RFC8017] 1.掩码生成函数中使用的摘要和被签名的摘要都是[SHS]中定义的相应散列算法。 Salt的长度必须等于摘要算法的长度。 如果公钥在X.509证书中携带，则它必须使用RSASSA-PSS OID [RFC5756] 。 在证书签名中使用时，算法参数必须是DER编码的。 如果存在相应的公钥参数，则签名中的参数必须与公钥中的参数相同。 


 Rescorla Standards Track [第43页] 
 
 RFC 8446 TLS 2018年8月


传统算法：表示不推荐使用的算法 
因为他们使用具有已知弱点的算法，特别是SHA-1，在这种情况下使用（1）RSA使用RSASSA-PKCS1-v1_5或（2）ECDSA。 这些值仅指出现在证书中的签名（参见第4.4.2.2节 ），并且未定义用于签名的TLS握手消息，尽管它们可能出现在“signature_algorithms”和“signature_algorithms_cert”中，以便与TLS 1.2向后兼容。 端点不应该协商这些算法，但允许这样做只是为了向后兼容。 提供这些值的客户端必须将它们列为最低优先级（在SignatureSchemeList中的所有其他算法之后列出）。 TLS 1.3服务器不得提供SHA-1签名证书，除非没有它可以生成有效的证书链（参见第4.4.2.2节 ）。 

自签名证书上的签名或信任锚证书的签名未经验证，因为它们开始了证书路径（参见[RFC5280]，第3.2节 ）。 开始证书路径的证书可以使用未在“signature_algorithms”扩展中支持的签名算法。

请注意，TLS 1.2以不同方式定义此扩展。 在协商该版本时，愿意协商TLS 1.2的TLS 1.3实现必须符合[RFC5246]的要求。 特别是： 

- TLS 1.2 ClientHellos可以省略此扩展。 

- 在TLS 1.2中，扩展包含散列/签名对。 这些对以两个八位字节编码，因此已分配SignatureScheme值以与TLS 1.2的编码对齐。 一些遗留对未分配。 自TLS 1.3起，这些算法已弃用。 任何实施都不得提供或协商。 特别是， 不得使用 MD5 [SLOTH] ，SHA-224和DSA。 

- ECDSA签名方案与TLS 1.2的ECDSA哈希/签名对一致。 但是，旧的语义并没有限制签名曲线。 如果协商了TLS 1.2，则必须准备实现以接受使用它们在“supported_groups”扩展中公布的任何曲线的签名。 

- 广告支持RSASSA-PSS（在TLS 1.3中是强制性的）的实现必须准备好接受使用该方案的签名，即使在协商TLS 1.2时也是如此。 在TLS 1.2中，RSASSA-PSS与RSA密码套件一起使用。 


 Rescorla Standards Track [第44页] 
 
 RFC 8446 TLS 2018年8月


 4.2.4 。  证书颁发机构

“certificate_authorities”扩展名用于指示端点支持的证书颁发机构（CA）以及接收端点应该使用哪个证书颁发机构来指导证书选择。 

“certificate_authorities”扩展的主体由CertificateAuthoritiesExtension结构组成。 

opaque DistinguishedName <1..2 ^ 16-1>; 

struct { 
DistinguishedName权限<3..2 ^ 16-1>; 
} CertificateAuthoritiesExtension; 

权威机构：可接受的专有名称[ X501 ]列表 
证书颁发机构，以DER编码[X690]格式表示。 这些可分辨名称为信任锚或从属CA指定所需的可分辨名称; 因此，该消息可用于描述已知的信任锚以及所需的授权空间。 

客户端可以在ClientHello消息中发送“certificate_authorities”扩展名。 服务器可以在CertificateRequest消息中发送它。 

“trusted_ca_keys”扩展[RFC6066]用于类似目的但更复杂，未在TLS 1.3中使用（尽管它可能出现在提供TLS早期版本的客户端的ClientHello消息中）。 
 4.2.5 。  OID过滤器

“oid_filters”扩展允许服务器提供一组OID /值对，它们希望客户端的证书匹配。 此扩展（如果由服务器提供）必须仅在CertificateRequest消息中发送。 

struct { 
opaque certificate_extension_oid <1..2 ^ 8-1>; opaque certificate_extension_values <0..2 ^ 16-1>; } OIDFilter; 

struct { 
OIDFilter过滤器<0..2 ^ 16-1>; 
} OIDFilterExtension; 



 Rescorla标准轨道[第45页] 
 
 RFC 8446 TLS 2018年8月


filters：证书扩展OID [ RFC5280 ]及其列表 
允许值，并以DER编码[X690]格式表示。 某些证书扩展OID允许多个值（例如，扩展密钥使用）。 如果服务器包含非空过滤器列表，则响应中包含的客户端证书必须包含客户端识别的所有指定扩展OID。 对于客户端识别的每个扩展OID，所有指定的值必须存在于客户端证书中（但证书也可以具有其他值）。 但是，客户端必须忽略并跳过任何无法识别的证书扩展OID。 如果客户端忽略了一些所需的证书扩展OID并提供了不满足请求的证书，则服务器可以自行决定是否在没有客户端身份验证的情况下继续连接，或者使用“unsupported_certificate”警报中止握手。 任何给定的OID绝不能在过滤器列表中出现多次。 

PKIX RFC定义了各种证书扩展OID及其对应的值类型。 根据类型，匹配的证书扩展值不一定是按位相等的。 预计TLS实现将依赖其PKI库来使用证书扩展OID执行证书选择。 

本文档定义了[RFC5280]中定义的两个标准证书扩展的匹配规则： 

- 当在密钥用法证书扩展中也声明请求中声明的所有密钥使用位时，证书中的密钥用法扩展与请求匹配。 

- 当在扩展密钥用法证书扩展中也找到请求中存在的所有关键用途OID时，证书中的扩展密钥用法扩展与请求匹配。 必须在请求中使用特殊的anyExtendedKeyUsage OID。 

单独的规范可以定义其他证书扩展的匹配规则。
 Rescorla标准轨道[第46页] 
 
 RFC 8446 TLS 2018年8月
 4.2.6 。  握手后客户端身份验证

“post_handshake_auth”扩展名用于表示客户端愿意执行握手后身份验证（ 第4.6.2节 ）。 服务器不得向不提供此扩展的客户端发送握手后的CertificateRequest。 服务器不得发送此扩展。 

struct {} PostHandshakeAuth; 

“post_handshake_auth”扩展名的“extension_data”字段为零长度。 
 4.2.7 。  支持的组

当客户端发送时，“supported_groups”扩展名表示客户端支持密钥交换的命名组，从最优先选择到最不优选。 

注意：在TLS 1.3之前的TLS版本中，此扩展名为“elliptic_curves”，仅包含椭圆曲线组。 参见[RFC8422]和[RFC7919] 。 此扩展也用于协商ECDSA曲线。 签名算法现在可以独立协商（参见第4.2.3节 ）。 

此扩展的“extension_data”字段包含“NamedGroupList”值： 

枚举{ 

/ *椭圆曲线组（ECDHE）* / secp256r1（0x0017），secp384r1（0x0018），secp521r1（0x0019），x25519（0x001D），x448（0x001E）， 

/ *有限域组（DHE）* / ffdhe2048（0x0100），ffdhe3072（0x0101），ffdhe4096（0x0102），ffdhe6144（0x0103），ffdhe8192（0x0104）， 

/ *保留代码点* / ffdhe_private_use（0x01FC..0x01FF），ecdhe_private_use（0xFE00..0xFEFF），（0xFFFF）} NamedGroup; 

struct { 
NamedGroup named_group_list <2..2 ^ 16-1>; 
NamedGroupList; 



 Rescorla标准轨道[第47页] 
 
 RFC 8446 TLS 2018年8月


椭圆曲线组（ECDHE）：表示支持 
相应的命名曲线，在FIPS 186-4 [DSS]或[RFC7748]中定义 。 值0xFE00至0xFEFF保留用于专用[RFC8126] 。 

有限域组（DHE）：表示对相应的支持 
有限字段组，在[RFC7919]中定义。 值0x01FC到0x01FF保留给专用。 

named_group_list中的项目根据发件人的首选项排序（最首选的选择）。 

从TLS 1.3开始，允许服务器向客户端发送“supported_groups”扩展。 在成功完成握手之前，客户端不得对“supported_groups”中的任何信息进行操作，但可以使用从成功完成的握手中获知的信息来更改在后续连接中他们在“key_share”扩展中使用的组。 如果服务器有一个组，它更喜欢“key_share”扩展名中的组，但仍然愿意接受ClientHello，它应该发送“supported_groups”来更新客户端的首选项视图; 此扩展应该包含服务器支持的所有组，无论客户端当前是否支持它们。 
 4.2.8 。  重点分享

“key_share”扩展包含端点的加密参数。 

客户端可以发送一个空的client_shares向量，以便从服务器请求组选择，但需要额外的往返（参见第4.1.4节 ）。 

struct { 
NamedGroup组; opaque key_exchange <1..2 ^ 16-1>; 
} KeyShareEntry; 

group：要交换的密钥的命名组。 

key_exchange：密钥交换信息。 该字段的内容由指定的组及其相应的定义确定。 有限域Diffie-Hellman [DH76]参数在4.2.8.1节中描述; Elliptic Curve Diffie-Hellman参数在4.2.8.2节中描述。 在ClientHello消息中，此扩展的“extension_data”字段包含“KeyShareClientHello”值：
 Rescorla Standards Track [第48页] 
 
 RFC 8446 TLS 2018年8月

struct { 
KeyShareEntry client_shares <0..2 ^ 16-1>; 
KeyShareClientHello; 

client_shares：降序提供的KeyShareEntry值列表 
客户偏好的顺序。 

如果客户端请求HelloRetryRequest，则此向量可以为空。 每个KeyShareEntry值必须对应于“supported_groups”扩展中提供的组，并且必须以相同的顺序出现。 但是，值可以是“supported_groups”扩展的非连续子集，并且可以省略最优选的组。 如果最优选的群体是新的并且不太可能在足够的地方得到支持以使它们的预生成关键份额有效，则可能出现这种情况。 

客户端可以提供与其提供的支持组数量一样多的KeyShareEntry值，每个值代表一组密钥交换参数。 例如，客户端可能会为多个椭圆曲线或多个FFDHE组提供共享。 每个KeyShareEntry的key_exchange值必须独立生成。 客户端不得为同一组提供多个KeyShareEntry值。 客户端不得为客户端的“supported_groups”扩展中未列出的组提供任何KeyShareEntry值。 服务器可以检查是否违反了这些规则，如果违反了规则，则使用“illegal_parameter”警报中止握手。 

在HelloRetryRequest消息中，此扩展的“extension_data”字段包含KeyShareHelloRetryRequest值： 

struct { 
NamedGroup selected_group; 
} KeyShareHelloRetryRequest; 

selected_group：服务器所支持的相互支持的组 
协商并请求重试的ClientHello / KeyShare。 

在HelloRetryRequest中收到此扩展后，客户端必须验证（1）selected_group字段是否对应于原始ClientHello中“supported_groups”扩展中提供的组，以及（2）selected_group字段不对应于组它是在原始ClientHello的“key_share”扩展名中提供的。 如果这些检查中的任何一个失败，那么客户端必须通过“illegal_parameter”警报中止握手。 否则，在发送新的ClientHello时，客户端必须将原始的“key_share”扩展名替换为仅包含触发HelloRetryRequest的selected_group字段中指示的组的新KeyShareEntry的扩展名。 


 Rescorla Standards Track [第49页] 
 
 RFC 8446 TLS 2018年8月



在ServerHello消息中，此扩展的“extension_data”字段包含KeyShareServerHello值： 

struct { 
KeyShareEntry server_share; 
KeyShareServerHello; 

server_share：位于同一组中的单个KeyShareEntry值 
作为客户的股份之一。 

如果使用（EC）DHE密钥建立，服务器在ServerHello中只提供一个KeyShareEntry。 该值必须与服务器为协商密钥交换选择的客户端提供的KeyShareEntry值位于同一组中。 服务器不得为客户端的“supported_groups”扩展中未指示的任何组发送KeyShareEntry，并且在使用“psk_ke”PskKeyExchangeMode时不得发送KeyShareEntry。 如果客户端收到（EC）DHE密钥建立和包含“key_share”扩展的HelloRetryRequest，则客户端必须验证ServerHello中选定的NamedGroup是否与HelloRetryRequest中的相同。 如果此检查失败，客户端必须通过“illegal_parameter”警报中止握手。 
 4.2.8.1 。  Diffie-Hellman参数

客户端和服务器的Diffie-Hellman [DH76]参数在KeyShare结构中的KeyShareEntry的opaque key_exchange字段中进行编码。 opaque值包含指定组的Diffie-Hellman公共值（Y = g ^ X mod p）（参见[RFC7919]的组定义），编码为大端整数，并用左边填充，大小为0 p以字节为单位。 

注意：对于给定的Diffie-Hellman组，填充会导致所有公钥具有相同的长度。 

同行必须通过确保1 <Y <p-1来验证彼此的公钥Y. 此检查可确保远程对等方正确运行，并且不会将本地系统强制转换为小型子组。
 Rescorla标准跟踪[第50页] 
 
 RFC 8446 TLS 2018年8月
 4.2.8.2 。  ECDHE参数

客户端和服务器的ECDHE参数在KeyShare结构中的KeyShareEntry的opaque key_exchange字段中进行编码。 

对于secp256r1，secp384r1和secp521r1，内容是以下结构的序列化值： 

struct { 
uint8 legacy_form = 4; 不透明的X [coordinate_length]; 不透明的Y [coordinate_length]; 
} UncompressedPointRepresentation; 

X和Y分别是网络字节顺序中x和y值的二进制表示。 没有内部长度标记，因此每个数字表示占用曲线参数所暗示的八位字节。 对于P-256，这意味着X和Y中的每一个使用32个八位字节，如果需要，在左边填充零。 对于P-384，它们各占48个八位字节。 对于P-521，它们各占66个八位字节。 

对于曲线secp256r1，secp384r1和secp521r1，对等体必须通过确保该点是椭圆曲线上的有效点来验证彼此的公共值Q. 适当的验证程序在[ECDSA]的第4.3.7节中定义，或者在[基准]的第5.6.2.3节中定义。 该过程包括三个步骤：（1）验证Q不是无穷远处的点（O），（2）验证对于Q =（x，y），整数x和y都在正确的区间内，并且（3） ）确保（x，y）是椭圆曲线方程的正确解。 对于这些曲线，实现者不需要验证正确子组中的成员资格。 

对于X25519和X448，公共值的内容是[RFC7748]中定义的相应函数的字节串输入和输出： X25519为32字节，X448为56字节。 

注意：1.3之前的TLS版本允许点格式协商; TLS 1.3删除了此功能，支持每条曲线的单点格式。 
 4.2.9 。  预共享密钥交换模式

为了使用PSK，客户端还必须发送“psk_key_exchange_modes”扩展名。 此扩展的语义是客户端仅支持使用这些模式的PSK，这限制了此ClientHello中提供的PSK的使用以及服务器可能通过NewSessionTicket提供的PSK。 如果客户端提供“pre_shared_key”扩展名，则必须提供“psk_key_exchange_modes”扩展名。 如果客户端提供“pre_shared_key”而没有“psk_key_exchange_modes”扩展名，则服务器必须中止握手。 服务器不能选择客户端未列出的密钥交换模式。 此扩展还限制了PSK恢复使用的模式。 服务器不应该使用与广告模式不兼容的票证发送NewSessionTicket; 但是，如果服务器这样做，那么影响就是客户端尝试恢复失败。 



 Rescorla Standards Track [第51页] 
   RFC 8446 TLS 2018年8月 
服务器不得发送“psk_key_exchange_modes”扩展名。 

enum {psk_ke（0），psk_dhe_ke（1），（255）} PskKeyExchangeMode; 

struct { 
PskKeyExchangeMode ke_modes <1..255>; 
} PskKeyExchangeModes; 

psk_ke：仅限PSK密钥建立。 在这种模式下，服务器 
绝不能提供“key_share”值。 

psk_dhe_ke：具有（EC）DHE密钥建立的PSK。 在这种模式下， 
客户端和服务器必须提供“key_share”值，如第4.2.8节所述。 

分配的任何未来值必须确保传输的协议消息明确地识别服务器选择的模式; 目前，这由ServerHello中存在“key_share”表示。 
 4.2.10 。  早期数据指示

当使用PSK并且允许该PSK的早期数据时，客户端可以在其第一条消息中发送应用数据。 如果客户端选择这样做，它必须提供“pre_shared_key”和“early_data”扩展。 

此扩展的“extension_data”字段包含“EarlyDataIndication”值。 struct {}空;
 Rescorla Standards Track [第52页] 
 
 RFC 8446 TLS 2018年8月

struct { 
select（Handshake.msg_type）{ 
case new_session_ticket：uint32 max_early_data_size; case client_hello：空; case encrypted_extensions：空; 
}; 
} EarlyDataIndication; 

有关使用max_early_data_size字段的详细信息，请参见第4.6.1节 。 

0-RTT数据（版本，对称密码套件，应用层协议协商（ALPN） [RFC7301]协议等）的参数是与使用中的PSK相关联的参数。 对于外部配置的PSK，关联值是与密钥一起提供的值。 对于通过NewSessionTicket消息建立的PSK，关联值是在建立PSK的连接中协商的值。 用于加密早期数据的PSK必须是客户端“pre_shared_key”扩展中列出的第一个PSK。 

对于通过NewSessionTicket配置的PSK，服务器必须验证所选PSK标识的票证年龄（通过从PskIdentity.obfuscated_ticket_age modulo 2 ^ 32中减去ticket_age_add计算得出）在票证发布后的时间范围内（见第8节） ）。 如果不是，服务器应该继续握手但拒绝0-RTT，并且不应采取任何其他假设此ClientHello是新鲜的操作。 

在第一次航班中发送的0-RTT消息具有与在其他航班（握手和application_data）中发送的相同类型的消息相同（加密）的内容类型，但受不同密钥的保护。 在收到服务器的已完成消息后，如果服务器已接受早期数据，则将发送EndOfEarlyData消息以指示密钥更改。 此消息将使用0-RTT流量密钥进行加密。 接收“early_data”扩展的服务器必须以下列三种方式之一运行：
 Rescorla Standards Track [第53页] 
 
 RFC 8446 TLS 2018年8月

- 忽略扩展并返回常规的1-RTT响应。 然后，服务器尝试使用握手流量密钥对接收的记录进行去保护，丢弃过去保护失败的记录（直到配置的max_early_data_size），从而跳过早期数据。 一旦记录成功去保护，它将被视为客户端第二次飞行的开始，服务器将进行普通的1-RTT握手。 

- 请求客户端通过响应HelloRetryRequest发送另一个ClientHello。 客户端不得在其后续ClientHello中包含“early_data”扩展。 然后，服务器通过跳过具有外部内容类型“application_data”（表示它们已加密）的所有记录来忽略早期数据，直到配置的max_early_data_size。 

- 在EncryptedExtensions中返回自己的“early_data”扩展，表明它打算处理早期数据。 服务器不可能只接受早期数据消息的子集。 即使服务器发送接受早期数据的消息，实际的早期数据本身可能在服务器生成此消息时已经在飞行中。 

为了接受早期数据，服务器必须接受PSK密码套件并选择客户端“pre_shared_key”扩展中提供的第一个密钥。 此外，它必须验证以下值与所选PSK相关的值是否相同： 

- TLS版本号 

- 选定的密码套件 

- 所选的ALPN [RFC7301]协议（如果有） 

这些要求是使用相关PSK执行1-RTT握手所需的超集。 对于外部建立的PSK，关联值是与密钥一起提供的值。 对于通过NewSessionTicket消息建立的PSK，关联值是在建立故障单的连接中协商的值。

未来的扩展必须定义它们与0-RTT的交互。 如果这些检查中的任何一个失败，则服务器不得使用扩展进行响应，并且必须使用上面列出的前两种机制之一丢弃所有首先飞行数据（因此回退到1-RTT或2-RTT）。 如果客户端尝试0-RTT握手但服务器拒绝它，则服务器通常不会有0-RTT记录保护密钥，而必须使用试用解密（使用1-RTT握手密钥或通过查找明文ClientHello在HelloRetryRequest的情况下）找到第一个非0-RTT消息。
 Rescorla Standards Track [第54页] 
 
 RFC 8446 TLS 2018年8月

如果服务器选择接受“early_data”扩展，那么在处理早期数据记录时，它必须遵守为所有记录指定的相同错误处理要求。 具体来说，如果服务器无法在接受的“early_data”扩展名后解密0-RTT记录，则必须根据第5.2节以“bad_record_mac”警报终止连接。 

如果服务器拒绝“early_data”扩展，则客户端应用程序可以选择在握手完成后重新传输先前在早期数据中发送的应用程序数据。 请注意，早期数据的自动重传可能导致关于连接状态的错误假设。 例如，当协商连接从用于早期数据的协议中选择不同的ALPN协议时，应用程序可能需要构造不同的消息。 同样，如果早期数据假设有关连接状态的任何内容，则在握手完成后可能会错误地发送。 

TLS实现不应自动重新发送早期数据; 应用程序可以更好地决定何时重传。 除非协商连接选择相同的ALPN协议，否则TLS实现绝不能自动重新发送早期数据。 
 4.2.11 。  预共享密钥扩展

“pre_shared_key”扩展用于协商与PSK密钥建立相关联的给定握手使用的预共享密钥的标识。 此扩展的“extension_data”字段包含“PreSharedKeyExtension”值：
 Rescorla标准轨道[第55页] 
 
 RFC 8446 TLS 2018年8月

struct { 
不透明的身份<1..2 ^ 16-1>; uint32 obfuscated_ticket_age; PskIdentity; 

opaque PskBinderEntry <32..255>; 

struct {PskIdentity identities <7..2 ^ 16-1>; PskBinderEntry粘合剂<33..2 ^ 16-1>; } OfferedPsks; 

struct { 
select（Handshake.msg_type）{ 
case client_hello：OfferedPsks; case server_hello：uint16 selected_identity; 
}; 
} PreSharedKeyExtension; 

identity：密钥的标签。 例如，一张票（如 
附录B.3.4 ）或外部建立的预共享密钥的标签。 

obfuscated_ticket_age：密钥时代的模糊版本。 
第4.2.11.1节描述了如何为通过NewSessionTicket消息建立的标识形成此值。 对于外部建立的标识，应该使用0的obfuscated_ticket_age，服务器必须忽略该值。 

身份：客户愿意的身份列表 
与服务器协商。 如果与“early_data”扩展一起发送（参见第4.2.10节 ），则第一个标识是用于0-RTT数据的标识。 

binders：一系列HMAC值，每个值对应一个值 
身份列表和相同的顺序，如下所述计算。 

selected_identity：服务器选择的标识表示为 
（基于0）索引到客户端列表中的标识。 

每个PSK与单个哈希算法相关联。 对于通过票证机制建立的PSK（ 第4.6.1节 ），这是建立票证的连接上的KDF哈希算法。 对于外部建立的PSK，必须在PSK建立时设置哈希算法，如果没有定义这样的算法，则默认为SHA-256。 服务器必须确保它选择兼容的PSK（如果有的话）和密码套件。 


 Rescorla标准轨道[第56页] 
 
 RFC 8446 TLS 2018年8月



在TLS 1.3之前的TLS版本中，服务器名称标识（SNI）值旨在与会话关联（ [RFC6066]的第3节 ），要求服务器强制与会话关联的SNI值与在恢复握手中指定的一个。 然而，实际上，这些实现在它们将使用的两个提供的SNI值中的哪一个上不一致，导致一致性要求事实上由客户端强制执行。 在TLS 1.3中，始终在恢复握手中明确指定SNI值，并且服务器无需将SNI值与故障单关联。 但是，客户应该将PSI与PSK一起存储，以满足第4.6.1节的要求。 

实现者注意：当会话恢复是PSK的主要用例时，实现PSK /密码套件匹配要求的最直接方式是首先协商密码套件，然后排除任何不兼容的PSK。 任何未知的PSK（例如，不在PSK数据库中或用未知密钥加密的PSK）都应该被忽略。 如果找不到可接受的PSK，服务器应该尽可能执行非PSK握手。 如果向后兼容性很重要，客户提供的，外部建立的PSK应该影响密码套件的选择。 

在接受PSK密钥建立之前，服务器必须验证相应的绑定值（参见下面的第4.2.11.2节 ）。 如果此值不存在或未验证，则服务器必须中止握手。 服务器不应该尝试验证多个绑定器; 相反，他们应该选择单个PSK并仅验证与该PSK相对应的活页夹。 有关此要求的安全原理，请参见第8.2节和附录E.6 。 为了接受PSK密钥建立，服务器发送指示所选身份的“pre_shared_key”扩展名。 

客户端必须验证服务器的selected_identity是否在客户端提供的范围内，服务器选择了一个密码套件，指示与PSK关联的哈希值，并且如果ClientHello“psk_key_exchange_modes”扩展需要，则存在服务器“key_share”扩展名。 如果这些值不一致，客户端必须使用“illegal_parameter”警报中止握手。 如果服务器提供“early_data”扩展，则客户端必须验证服务器的selected_identity为0.如果返回任何其他值，则客户端必须使用“illegal_parameter”警报中止握手。
 Rescorla标准轨道[第57页] 
 
 RFC 8446 TLS 2018年8月

“pre_shared_key”扩展必须是ClientHello中的最后一个扩展（这有利于实现，如下所述）。 服务器必须检查它是否是最后一个扩展，否则将通过“illegal_parameter”警报使握手失败。 
 4.2.11.1 。  门票年龄

客户端对故障单年龄的视图是自收到NewSessionTicket消息以来的时间。 客户不得尝试使用年龄大于机票随附的“ticket_lifetime”值的机票。 每个PskIdentity的“obfuscated_ticket_age”字段包含一个模糊版本的票证年龄，该版本是通过获取年龄（以毫秒为单位）并添加票证中包含的“ticket_age_add”值（参见第4.6.1节 ），模2 ^ 32来形成的。 此添加可防止被动观察者关联连接，除非重复使用票证。 请注意，NewSessionTicket消息中的“ticket_lifetime”字段以秒为单位，但“obfuscated_ticket_age”以毫秒为单位。 由于票证生命周期限制为一周，因此即使以毫秒为单位，32位也足以代表任何合理的年龄。 
 4.2.11.2 。  PSK活页夹

PSK绑定器值形成PSK与当前握手之间的绑定，以及生成PSK的握手（如果通过NewSessionTicket消息）与当前握手之间的绑定。 绑定器列表中的每个条目都计算为HMAC，而不是转录本哈希（参见第4.4.1节 ），其中包含部分ClientHello，包括PreSharedKeyExtension.identities字段。 也就是说，它包括所有ClientHello，但不包括绑定器列表本身。 消息的长度字段（包括总长度，扩展块的长度和“pre_shared_key”扩展的长度）都被设置为好像存在正确长度的绑定器。 

PskBinderEntry的计算方法与完成的消息（ 第4.4.4节 ）相同，但BaseKey是通过来自相应PSK的密钥调度导出的binder_key（参见第7.1节 ）。 如果握手包含HelloRetryRequest，则初始ClientHello和HelloRetryRequest将与新ClientHello一起包含在脚本中。 例如，如果客户端发送ClientHello1，其绑定将通过以下方式计算：
 Rescorla标准跟踪[第58页] 
 
 RFC 8446 TLS 2018年8月

成绩单散列（截断（ClientHello1）） 

Truncate（）从ClientHello中删除绑定器列表。 

如果服务器以HelloRetryRequest响应，然后客户端发送ClientHello2，则其计算机将通过以下方式计算： 

成绩单散列（ClientHello1， 
HelloRetryRequest，Truncate（ClientHello2）） 

完整的ClientHello1 / ClientHello2包含在所有其他握手哈希计算中。 请注意，在第一个航班中，Truncate（ClientHello1）直接进行哈希处理，但在第二个航班中，ClientHello1经过哈希处理，然后作为“message_hash”消息重新注入，如第4.4.1节所述。 
 4.2.11.3 。  处理订单

允许客户端“流式传输”0-RTT数据，直到它们收到服务器的Finished，然后发送EndOfEarlyData消息，然后是其余的握手。 为了避免死锁，当接受“early_data”时，服务器必须处理客户端的ClientHello，然后立即发送它们的消息，而不是在发送ServerHello之前等待客户端的EndOfEarlyData消息。 
 4.3 。  服务器参数

来自服务器的下两条消息EncryptedExtensions和CertificateRequest包含来自服务器的信息，用于确定握手的其余部分。 这些消息使用从server_handshake_traffic_secret派生的密钥加密。
 Rescorla Standards Track [第59页] 
 
 RFC 8446 TLS 2018年8月
 4.3.1 。  加密扩展

在所有握手中，服务器必须在ServerHello消息之后立即发送EncryptedExtensions消息。 这是在server_handshake_traffic_secret派生的密钥下加密的第一条消息。 

EncryptedExtensions消息包含可以受到保护的扩展，即，任何不需要建立加密上下文但与单个证书无关的扩展。 客户端必须检查EncryptedExtensions是否存在任何禁用扩展，如果发现任何禁止扩展，必须通过“illegal_parameter”警报中止握手。 

此消息的结构： 

struct { 
扩展扩展名<0..2 ^ 16-1>; 
加密的扩展; 

扩展：扩展列表。 有关更多信息，请参阅 
第4.2节中的表格。 
 4.3.2 。  证书申请

使用证书进行身份验证的服务器可以选择从客户端请求证书。 此消息，如果发送，必须遵循EncryptedExtensions。 

此消息的结构： 

struct { 
opaque certificate_request_context <0..2 ^ 8-1>; 扩展名扩展名<2..2 ^ 16-1>; 
} CertificateRequest;
 Rescorla标准轨道[第60页] 
 
 RFC 8446 TLS 2018年8月
certificate_request_context：一个不透明的字符串，用于标识 
证书请求，将在客户端的证书消息中回显。 certificate_request_context必须在此连接的范围内是唯一的（从而防止重放客户端CertificateVerify消息）。 除非用于第4.6.2节中描述的握手后认证交换，否则该字段应为零长度。 当请求握手后认证时，服务器应该使上下文不可预测到客户端（例如，通过随机生成它），以防止临时访问客户端私钥的攻击者预先计算有效的CertificateVerify消息。 

extensions：一组描述参数的扩展 
要求的证书。 必须指定“signature_algorithms”扩展名，如果为此消息定义，则可以选择包含其他扩展名。 客户端必须忽略无法识别的扩展。 

在早期版本的TLS中，CertificateRequest消息携带了服务器可接受的签名算法和证书颁发机构的列表。 在TLS 1.3中，前者通过发送“signature_algorithms”和可选的“signature_algorithms_cert”扩展来表示。 后者通过发送“certificate_authorities”扩展名来表示（参见第4.2.4节 ）。 

使用PSK进行身份验证的服务器不得在主握手中发送CertificateRequest消息，尽管它们可以在握手后身份验证中发送它（参见第4.6.2节 ），前提是客户端已发送“post_handshake_auth”扩展（参见第4.2节） .6 ）。 
 4.4 。  验证消息 
如第2节所述 ，TLS通常使用一组通用消息进行身份验证，密钥确认和握手完整性：Certificate，CertificateVerify和Finished。 （PSK活页夹也以类似的方式执行密钥确认。）这三条消息总是作为握手航班中的最后一条消息发送。 Certificate和CertificateVerify消息仅在某些情况下发送，如下所述。 完成的消息始终作为认证块的一部分发送。 这些消息在从[sender] _handshake_traffic_secret派生的密钥下加密。 身份验证消息的计算均匀地采用以下输入：
 Rescorla Standards Track [第61页] 
 
 RFC 8446 TLS 2018年8月

- 要使用的证书和签名密钥。 

- 握手上下文，包含要包含在转录本哈希中的消息集。 

- 用于计算MAC密钥的基本密钥。 

根据这些输入，消息包含： 

证书：用于身份验证的证书以及链中的任何支持证书。 请注意，基于证书的客户端身份验证在PSK握手流程（包括0-RTT）中不可用。 

CertificateVerify：超过值的签名 
Transcript-Hash（握手上下文，证书）。 

完成：超过值Transcript-Hash的MAC（握手上下文， 
Certificate，CertificateVerify）使用从Base Key派生的MAC密钥。 

下表定义了每个方案的握手上下文和MAC Base Key： 
    + ----------- + ------------------------- + ----------- ------------------ +
    | 模式| 握手语境| 基本密钥|
    + ----------- + ------------------------- + ----------- ------------------ +
    | 服务器|  ClientHello ...稍后|  server_handshake_traffic_ |
    |  |  EncryptedExtensions / | 秘密|
    |  |  CertificateRequest |  |
    |  |  |  |
    | 客户|  ClientHello ...稍后|  client_handshake_traffic_ |
    |  | 服务器| 秘密|
    |  | 完成/ EndOfEarlyData |  |
    |  |  |  |
    | 后|  ClientHello ...客户端|  client_application_traffic_ |
    | 握手| 完成+ |  secret_N |
    |  |  CertificateRequest |  |
    + ----------- + ------------------------- + ----------- ------------------ +
 Rescorla Standards Track [第62页] 
 
 RFC 8446 TLS 2018年8月
 4.4.1 。  成绩单哈希

TLS中的许多加密计算都使用了转录本哈希。 该值是通过散列每个包含的握手消息的串联来计算的，包括携带握手消息类型和长度字段的握手消息头，但不包括记录层头。 也就是说， 
     Transcript-Hash（M1，M2，... Mn）=哈希（M1 || M2 || ... || Mn）

作为此一般规则的例外，当服务器使用HelloRetryRequest响应ClientHello时，ClientHello1的值将替换为包含Hash（ClientHello1）的握手类型“message_hash”的特殊合成握手消息。 也就是说， 
   Transcript-Hash（ClientHello1，HelloRetryRequest，... Mn）=
      哈希（message_hash || / *握手类型* /
            00 00 Hash.length ||  / *握手消息长度（字节）* /
           哈希（ClientHello1）||  / * ClientHello1的哈希* /
            HelloRetryRequest ||  ...... ||  MN）

这种结构的原因是允许服务器通过在cookie中仅存储ClientHello1的哈希来执行无状态HelloRetryRequest，而不是要求它导出整个中间哈希状态（参见第4.2.2节 ）。 

具体来说，转录本哈希始终取自以下握手消息序列，从第一个ClientHello开始，仅包括已发送的消息：ClientHello，HelloRetryRequest，ClientHello，ServerHello，EncryptedExtensions，服务器CertificateRequest，服务器证书，服务器CertificateVerify，服务器已完成，EndOfEarlyData，客户端证书，客户端CertificateVerify，客户端已完成。 

通常，实现可以通过基于协商的散列保持运行的转录本散列值来实现转录本。 但请注意，后续的握手后身份验证不会互相包含，只是主要握手结束时的消息。
 Rescorla标准轨道[第63页] 
 
 RFC 8446 TLS 2018年8月
 4.4.2 。  证书

此消息将端点的证书链传送给对等方。 

每当商定的密钥交换方法使用证书进行身份验证时，服务器必须发送证书消息（这包括本文档中定义的除PSK之外的所有密钥交换方法）。 

当且仅当服务器通过CertificateRequest消息请求客户端认证时，客户端必须发送证书消息（ 第4.3.2节 ）。 如果服务器请求客户端身份验证但没有合适的证书可用，则客户端必须发送不包含证书的证书消息（即，“certificate_list”字段的长度为0）。 无论证书消息是否为空，都必须发送完成的消息。 

此消息的结构： 

枚举{ 
X509（0），RawPublicKey（2），（255）} CertificateType; 

struct { 
select（certificate_type）{ 
case RawPublicKey： 
/ *来自RFC 7250 ASN.1_subjectPublicKeyInfo * / opaque ASN1_subjectPublicKeyInfo <1..2 ^ 24-1>; 

案例X509： 
opaque cert_data <1..2 ^ 24-1>; 
}; 扩展扩展名<0..2 ^ 16-1>; } CertificateEntry; 

struct {opaque certificate_request_context <0..2 ^ 8-1>; CertificateEntry certificate_list <0..2 ^ 24-1>; 
} 证书;
 Rescorla Standards Track [第64页] 
   RFC 8446 TLS 2018年8月 
certificate_request_context：如果此消息是对a的响应 
CertificateRequest，该消息中certificate_request_context的值。 否则（在服务器认证的情况下），该字段应为零长度。 

certificate_list：CertificateEntry结构的序列（链）， 
每个包含一个证书和一组扩展。 

extensions：CertificateEntry的一组扩展值。 该 
“扩展”格式在4.2节中定义。 目前服务器证书的有效扩展包括OCSP状态扩展[RFC6066]和SignedCertificateTimestamp扩展[RFC6962] ; 也可以为此消息定义未来扩展。 来自服务器的证书消息中的扩展必须对应于ClientHello消息中的扩展。 来自客户端的证书消息中的扩展必须对应于来自服务器的CertificateRequest消息中的扩展。 如果扩展适用于整个链，它应该包含在第一个CertificateEntry中。 

如果未在EncryptedExtensions中协商相应的证书类型扩展名（“server_certificate_type”或“client_certificate_type”），或者协商了X.509证书类型，则每个CertificateEntry都包含DER编码的X.509证书。 发件人的证书必须位于列表中的第一个CertificateEntry中。 以下每个证书都应该直接证明其前面的证书。 由于证书验证要求信任锚独立分发，因此可以从链中省略指定信任锚的证书，前提是已知支持的对等方拥有任何省略的证书。

注意：在TLS 1.3之前，“certificate_list”命令要求每个证书对其前面的证书进行认证; 但是，一些实现允许一些灵活性。 服务器有时会为过渡目的发送当前和已弃用的中间件，而其他服务器只是配置不正确，但这些情况仍然可以正确验证。 为了获得最大的兼容性，所有实现都应该准备好处理来自任何TLS版本的潜在无关证书和任意排序，但必须首先是最终实体证书。 

如果协商了RawPublicKey证书类型，则certificate_list必须包含不超过一个CertificateEntry，其中包含[RFC7250]第3节中定义的ASN1_subjectPublicKeyInfo值。 OpenPGP证书类型[RFC6091]不得与TLS 1.3一起使用。 



 Rescorla Standards Track [第65页] 
 
 RFC 8446 TLS 2018年8月



服务器的certificate_list必须始终为非空。 如果客户端没有适当的证书要发送以响应服务器的身份验证请求，则会发送空的certificate_list。 
 4.4.2.1 。  OCSP状态和SCT扩展

[RFC6066]和[RFC6961]提供扩展以协商服务器向客户端发送OCSP响应。 在TLS 1.2及更低版本中，服务器回复空的扩展名以指示此扩展的协商，并且OCSP信息在CertificateStatus消息中携带。 在TLS 1.3中，服务器的OCSP信息在包含相关证书的CertificateEntry中的扩展中携带。 具体来说，来自服务器的“status_request”扩展的主体必须是[RFC6066]中定义的CertificateStatus结构，其解释如[RFC6960]中所定义。 

注意：不推荐使用status_request_v2扩展[RFC6961] 。 在处理ClientHello消息时，TLS 1.3服务器不得对其存在或信息进行操作; 特别是，他们不得在EncryptedExtensions，CertificateRequest或Certificate消息中发送status_request_v2扩展名。 TLS 1.3服务器必须能够处理包含它的ClientHello消息，因为它可能由希望在早期协议版本中使用它的客户端发送。 

服务器可以通过在其CertificateRequest消息中发送空的“status_request”扩展来请求客户端使用其证书呈现OCSP响应。 如果客户端选择发送OCSP响应，则其“status_request”扩展的主体必须是[RFC6066]中定义的CertificateStatus结构。 

类似地， [RFC6962]为服务器提供了一种机制，用于在TLS 1.2及更低版本的ServerHello中发送签名证书时间戳（SCT）作为扩展。 在TLS 1.3中，服务器的SCT信息在CertificateEntry的扩展中携带。
 Rescorla标准轨道[第66页] 
 
 RFC 8446 TLS 2018年8月
 4.4.2.2 。  服务器证书选择

以下规则适用于服务器发送的证书： 

- 证书类型必须是X.509v3 [RFC5280] ，除非另有明确协商（例如， [RFC7250] ）。 

- 服务器的终端实体证书的公钥（和相关限制）必须与客户端的“signature_algorithms”扩展（目前为RSA，ECDSA或EdDSA）中的所选验证算法兼容。 

- 证书必须允许密钥用于签名（即，如果存在密钥用法扩展，则必须设置digitalSignature位），并在客户端的“signature_algorithms”/“signature_algorithms_cert”扩展中指示签名方案（参见第4.2节）。 3 ）。 

- “server_name” [RFC6066]和“certificate_authorities”扩展用于指导证书选择。 由于服务器可能需要存在“server_name”扩展名，因此客户端应该在适用时发送此扩展名。 

服务器提供的所有证书必须由客户通告的签名算法签名，如果它能够提供这样的链（见4.2.3节 ）。 自签名的证书或预期为信任锚的证书不会作为链的一部分进行验证，因此可以使用任何算法进行签名。 

如果服务器无法生成仅通过指示的支持算法签名的证书链，那么它应该通过向客户端发送其选择的证书链来继续握手，该证书链可能包括客户端不知道的算法。 这个回退链通常不应该使用弃用的SHA-1哈希算法，但如果客户端的广告允许，可以这样做，否则不得这样做。 

如果客户端无法使用提供的证书构造可接受的链并决定中止握手，那么它必须使用适当的证书相关警报中止握手（默认情况下，“unsupported_certificate”;有关更多信息，请参见第6.2节 ）。

如果服务器具有多个证书，则会根据上述条件选择其中一个证书（除了其他条件，例如传输层端点，本地配置和首选项）。 




 Rescorla标准轨道[第67页] 
 
 RFC 8446 TLS 2018年8月


 4.4.2.3 。  客户证书选择

以下规则适用于客户端发送的证书： 

- 证书类型必须是X.509v3 [RFC5280] ，除非另有明确协商（例如， [RFC7250] ）。 

- 如果CertificateRequest消息中存在“certificate_authorities”扩展名，则证书链中的至少一个证书应该由其中一个列出的CA颁发。 

- 证书必须使用可接受的签名算法进行签名，如第4.3.2节所述 。 请注意，这放宽了对先前版本的TLS中的证书签名算法的限制。 

- 如果CertificateRequest消息包含非空的“oid_filters”扩展，则终端实体证书必须与客户端识别的扩展OID匹配，如第4.2.5节中所述。 
 4.4.2.4 。  接收证书消息

通常，详细的证书验证程序超出了TLS的范围（参见[RFC5280] ）。 本节提供特定于TLS的要求。 

如果服务器提供空的证书消息，则客户端务必使用“decode_error”警报中止握手。 

如果客户端没有发送任何证书（即，它发送一个空的证书消息），服务器可以自行决定是否继续握手而不进行客户端身份验证，或者使用“certificate_required”警报中止握手。 此外，如果证书链的某些方面是不可接受的（例如，它没有由已知的可信CA签名），则服务器可以自行决定是继续握手（考虑客户端未经身份验证）还是中止握手。 

任何端点接收任何使用任何签名算法使用MD5哈希验证所需的证书都必须使用“bad_certificate”警报中止握手。 不推荐使用SHA-1，并且建议任何接收任何使用SHA-1哈希使用任何签名算法验证的证书的端点都会使用“bad_certificate”警报中止握手。 为清楚起见，这意味着端点可以接受这些算法用于自签名或信任锚的证书。 建议所有端点尽快转换为SHA-256或更好，以保持与当前正在逐步取消SHA-1支持的实现的互操作性。 


 Rescorla Standards Track [第68页] 
 
 RFC 8446 TLS 2018年8月



请注意，可以使用不同的签名算法（例如，使用ECDSA密钥签名的RSA密钥）对包含一个签名算法的密钥的证书进行签名。 
 4.4.3 。  证书验证

此消息用于提供端点拥有与其证书对应的私钥的明确证据。 CertificateVerify消息还为此时的握手提供完整性。 服务器必须在通过证书进行身份验证时发送此消息。 客户端必须在通过证书进行身份验证时发送此消息（即，当证书消息非空时）。 发送时，此消息必须在证书消息之后立即出现，并且紧接在完成消息之前。 

此消息的结构： 

struct { 
SignatureScheme算法; 不透明签名<0..2 ^ 16-1>; 
} CertificateVerify; 

算法字段指定使用的签名算法（有关此类型的定义，请参见第4.2.3节 ）。 签名是使用该算法的数字签名。 签名中涵盖的内容是第4.4.1节中描述的哈希输出，即： 

Transcript-Hash（握手语境，证书） 

然后通过以下连接计算数字签名： 

- 由八位字节32（0x20）组成的字符串，重复64次 

- 上下文字符串 

- 单个0字节，用作分隔符 

- 要签名的内容此结构旨在防止对先前版本的TLS的攻击，其中ServerKeyExchange格式意味着攻击者可以获得具有所选32字节前缀（ClientHello.random）的消息的签名。 最初的64字节填充将清除该前缀以及服务器控制的ServerHello.random。
 Rescorla Standards Track [第69页] 
   RFC 8446 TLS 2018年8月 
服务器签名的上下文字符串是“TLS 1.3，服务器CertificateVerify”。 客户端签名的上下文字符串是“TLS 1.3，客户端CertificateVerify”。 它用于在不同的上下文中提供签名之间的分离，帮助抵御潜在的跨协议攻击。 

例如，如果transcript hash是32字节01（这个长度对SHA-256有意义），服务器CertificateVerify的数字签名所涵盖的内容将是： 

202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020 2020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020

在发送方，计算CertificateVerify消息的签名字段的过程作为输入： 

- 数字签名所涵盖的内容 

- 与上一条消息中发送的证书对应的私有签名密钥 

如果服务器发送CertificateVerify消息，则签名算法必须是客户端“signature_algorithms”扩展中提供的消息，除非在没有不支持的算法的情况下不能生成有效的证书链（参见第4.2.3节 ）。 

如果由客户端发送，则签名中使用的签名算法必须是CertificateRequest消息中“signature_algorithms”扩展的supported_signature_algorithms字段中存在的签名算法之一。 

此外，签名算法必须与发送者的终端实体证书中的密钥兼容。 无论RSASSA-PKCS1-v1_5算法是否出现在“signature_algorithms”中，RSA签名都必须使用RSASSA-PSS算法。 SHA-1算法绝不能用于CertificateVerify消息的任何签名。 本规范中的所有SHA-1签名算法仅定义用于旧证书，并且对CertificateVerify签名无效。 




 Rescorla Standards Track [第70页] 
 
 RFC 8446 TLS 2018年8月



CertificateVerify消息的接收者必须验证签名字段。 验证过程需要输入： 

- 数字签名所涵盖的内容 

- 在关联的证书消息中找到的最终实体证书中包含的公钥 

- 在CertificateVerify消息的签名字段中收到的数字签名 

如果验证失败，接收方必须通过“decrypt_error”警报终止握手。 
 4.4.4 。  成品

完成消息是验证块中的最后一条消息。 提供握手和计算密钥的身份验证至关重要。 

完成消息的收件人必须验证内容是否正确，如果不正确，必须使用“decrypt_error”警报终止连接。 

一旦一方已发送其已完成消息并已收到并验证来自其对等方的已完成消息，它就可以开始通过该连接发送和接收应用数据。 有两种设置允许在接收对等完成之前发送数据： 

1.客户端发送0-RTT数据，如第4.2.10节所述。 

2.服务器可以在发送第一个航班后发送数据，但由于握手尚未完成，他们无法保证对等方的身份或其活跃性（即，ClientHello可能已被重播）。 用于计算Finished消息的密钥是使用HKDF从第4.4节中定义的Base Key计算的（参见第7.1节 ）。 特别：
 Rescorla Standards Track [第71页] 
 
 RFC 8446 TLS 2018年8月

finished_key = 
HKDF-Expand-Label（BaseKey，“已完成”，“”，Hash.length） 

此消息的结构： 

struct { 
opaque verify_data [Hash.length]; 
完成了; 

verify_data值计算如下： 

verify_data = 
HMAC（finished_key， 
Transcript-Hash（握手语境， 
证书*，CertificateVerify *）） 

*仅包括在内。 

HMAC [RFC2104]使用哈希算法进行握手。 如上所述，HMAC输入通常可以通过运行的散列来实现，即，此时只是握手散列。 

在以前版本的TLS中，verify_data总是12个八位字节。 在TLS 1.3中，它是用于握手的哈希的HMAC输出的大小。 

注意：警报和任何其他非握手记录类型不是握手消息，并且不包括在哈希计算中。 

完成消息之后的任何记录必须在适当的应用程序流量密钥下加密，如第7.2节所述。 特别是，这包括服务器响应客户端Certificate和CertificateVerify消息而发送的任何警报。 
 4.5 。  早期数据结束

struct {} EndOfEarlyData; 

如果服务器在EncryptedExtensions中发送了“early_data”扩展，则客户端必须在收到服务器完成后发送EndOfEarlyData消息。 如果服务器没有在EncryptedExtensions中发送“early_data”扩展，那么客户端绝不能发送EndOfEarlyData消息。 此消息表示已发送所有0-RTT application_data消息（如果有），并且以下记录在握手流量密钥下受到保护。 服务器不得发送此消息，并且接收它的客户端必须使用“unexpected_message”警报终止连接。 此消息在从client_early_traffic_secret派生的密钥下加密。 


 Rescorla Standards Track [第72页] 
 
 RFC 8446 TLS 2018年8月



 4.6 。  握手后消息

TLS还允许在主握手后发送其他消息。 这些消息使用握手内容类型，并在适当的应用程序流量密钥下加密。 
 4.6.1 。  新会话票证消息

在服务器收到客户端完成消息后的任何时间，它都可以发送NewSessionTicket消息。 此消息在票证值和从恢复主密钥派生的秘密PSK之间创建唯一关联（请参阅第7节 ）。 

客户端可以通过在其ClientHello中的“pre_shared_key”扩展中包含票证值来使用此PSK进行未来握手（ 第4.2.11节 ）。 服务器可以在一个连接上发送多个票证，可以在彼此之后立即发送，也可以在特定事件之后发送（参见附录C.4 ）。 例如，服务器可能会在握手后身份验证后发送新票证，以封装其他客户端身份验证状态。 多个票证对于各种用途的客户非常有用，包括： 

- 打开多个并行HTTP连接。 

- 通过（例如）Happy Eyeballs [RFC8305]或相关技术在接口和地址系列上执行连接竞赛。 

任何票证必须只能使用与用于建立原始连接的KDF哈希算法相同的密码套件来恢复。 

客户端必须只有在新的SNI值对原始会话中提供的服务器证书有效时才能恢复，并且只有在SNI值与原始会话中使用的SNI值匹配时才应该恢复。 后者是性能优化：通常，没有理由期望单个证书所涵盖的不同服务器能够接受彼此的票证; 因此，在这种情况下尝试恢复将浪费一次性票。 如果提供了这种指示（外部或通过任何其他方式），则客户端可以使用不同的SNI值恢复。 在恢复时，如果向调用应用程序报告SNI值，则实现必须使用在恢复ClientHello中发送的值而不是在先前会话中发送的值。 请注意，如果服务器实现拒绝具有不同SNI值的所有PSK标识，则这两个值始终相同。 




 Rescorla Standards Track [第73页] 
 
 RFC 8446 TLS 2018年8月



注意：虽然恢复主密钥取决于客户端的第二次飞行，但是不请求客户端身份验证的服务器可以独立计算转录的剩余部分，然后在发送完成后立即发送NewSessionTicket而不是等待客户端完成。 例如，在期望客户端并行打开多个TLS连接并且将从恢复握手的减少的开销中受益的情况下，这可能是适当的。 

struct { 
uint32 ticket_lifetime; uint32 ticket_age_add; opaque ticket_nonce <0..255>; opaque ticket <1..2 ^ 16-1>; 扩展扩展名<0..2 ^ 16-2>; 
} NewSessionTicket; 

ticket_lifetime：以32位为单位表示生命周期（以秒为单位） 
从发票开始的网络字节顺序的无符号整数。 服务器不得使用任何大于604800秒（7天）的值。 值为零表示应立即丢弃票证。 无论ticket_lifetime如何，客户端都不得将票证缓存超过7天，并且可以根据本地策略提前删除票证。 服务器可以将票证视为有效的时间段短于ticket_lifetime中所述的时间段。 

ticket_age_add：安全生成的随机32位值 
用于模糊客户端在“pre_shared_key”扩展名中包含的故障单的年龄。 客户端票证年龄以模2 ^ 32的形式添加到此值，以获取客户端传输的值。 服务器必须为它发送的每个票证生成一个新值。 

ticket_nonce：所有故障单中唯一的每票证值 
在这个连接上发布。
 Rescorla标准轨道[第74页] 
 
 RFC 8446 TLS 2018年8月
ticket：要用作PSK标识的票证的值。 该 
票证本身是一个不透明的标签。 它可以是数据库查找键，也可以是自加密和自我验证的值。 

extensions：票证的一组扩展值。 该 
“扩展”格式在4.2节中定义。 客户端必须忽略无法识别的扩展。 

当前为NewSessionTicket定义的唯一扩展名是“early_data”，表示该票证可用于发送0-RTT数据（ 第4.2.10节 ）。 它包含以下值： 

max_early_data_size：使用此票证时允许客户端发送的最大0-RTT数据量（以字节为单位）。 仅计算应用程序数据有效负载（即明文但不填充或内部内容类型字节）。 接收超过max_early_data_size字节的0-RTT数据的服务器应该使用“unexpected_message”警报终止连接。 请注意，由于缺少加密材料而拒绝早期数据的服务器将无法区分填充与内容，因此客户端不应该依赖于能够在早期数据记录中发送大量填充。 

与故障单关联的PSK计算如下： 

香港民主促进会展开标签（resumption_master_secret， 
“resumption”，ticket_nonce，Hash.length） 

由于ticket_nonce值对于每个NewSessionTicket消息都是不同的，因此将为每个故障单导出不同的PSK。 

请注意，原则上可以继续发布新票证，该票证无限期地延长最初从初始非PSK握手（最可能与对等证书相关联）得到的密钥材料的生命周期。 建议实施限制这种密钥材料的总寿命; 这些限制应考虑对等方证书的生命周期，干预撤销的可能性以及自对等方在线CertificateVerify签名以来的时间。
 4.6.2 。  握手后认证

当客户端发送了“post_handshake_auth”扩展（参见第4.2.6节 ）时，服务器可以在握手完成后随时通过发送CertificateRequest消息来请求客户端身份验证。 客户端必须使用适当的验证消息进行响应（参见第4.4节 ）。 如果客户端选择进行身份验证，则必须发送Certificate，CertificateVerify和Finished。 如果它拒绝，它必须发送一个证书消息，其中不包含证书，然后是完成。 给定响应的所有客户端消息必须连续出现在线路上，没有其他类型的中间消息。 


 Rescorla标准轨道[第75页] 
   RFC 8446 TLS 2018年8月 
在没有发送“post_handshake_auth”扩展名的情况下接收CertificateRequest消息的客户端必须发送“unexpected_message”致命警报。 

注意：由于客户端身份验证可能涉及提示用户，因此服务器必须做好一些延迟的准备，包括在发送CertificateRequest和接收响应之间接收任意数量的其他消息。 此外，接近连续接收多个CertificateRequests的客户端可能会以不同于它们的顺序响应它们（certificate_request_context值允许服务器消除响应的歧义）。 
 4.6.3 。  密钥和初始化向量更新

KeyUpdate握手消息用于指示发送方正在更新其发送加密密钥。 任何对等方在发送完成消息后都可以发送此消息。 在接收完成消息之前接收KeyUpdate消息的实现必须使用“unexpected_message”警报终止连接。 发送KeyUpdate消息后，发送方应使用下一代密钥发送其所有流量，如第7.2节所述计算。 收到KeyUpdate后，接收方必须更新其接收密钥。 

枚举{ 
update_not_requested（0），update_requested（1），（255） 
} KeyUpdateRequest; 

struct { 
KeyUpdateRequest request_update; 
} KeyUpdate; 

request_update：表示KeyUpdate的收件人 
应该用自己的KeyUpdate回复。 如果实现接收到任何其他值，它必须使用“illegal_parameter”警报终止连接。 

如果request_update字段设置为“update_requested”，则接收方必须在发送其下一个应用程序数据记录之前发送自己的KeyUpdate，其request_update设置为“update_not_requested”。 此机制允许任何一方强制更新整个连接，但会导致实现接收多个KeyUpdates，而它是静默的，以响应单个更新。 请注意，实现可以在发送KeyUpdate与request_update设置为“update_requested”并接收对等方的KeyUpdate之间接收任意数量的消息，因为这些消息可能已经在飞行中。 但是，由于发送和接收密钥是从独立的流量机密导出的，因此保留接收流量机密并不会威胁发送方更改密钥之前发送的数据的前向保密性。 


 Rescorla标准轨道[第76页] 
 
 RFC 8446 TLS 2018年8月



如果实现独立地发送它们自己的KeyUpdates，其request_update设置为“update_requested”并且它们在飞行中交叉，那么每一方也将发送响应，结果每一方增加两代。 

发送方和接收方都必须使用旧密钥加密其KeyUpdate消息。 此外，在接受使用新密钥加密的任何消息之前，双方必须强制接收具有旧密钥的KeyUpdate。 如果不这样做，可能会导致邮件截断攻击。


5 。 记录协议 

TLS记录协议接收要传输的消息，将数据分段为可管理的块，保护记录并传输结果。 接收的数据经过验证，解密，重新组装，然后交付给更高级别的客户。 

键入TLS记录，允许在同一记录层上复用多个更高级别的协议。 本文档指定了四种内容类型：handshake，application_data，alert和change_cipher_spec。 change_cipher_spec记录仅用于兼容性目的（参见附录D.4 ）。 

实现可以在发送或接收第一个ClientHello消息之后以及在接收到对等方的Finished消息之前的任何时间接收由单字节值0x01组成的未加密类型的change_cipher_spec记录，并且必须简单地丢弃它而不进行进一步处理。 请注意，此记录可能出现在执行期望受保护记录的握手处，因此有必要在尝试对记录进行去保护之前检测此情况。 接收任何其他change_cipher_spec值或接收受保护的change_cipher_spec记录的实现必须使用“unexpected_message”警报中止握手。 如果实现检测到在第一个ClientHello消息之前或在对等方的Finished消息之后收到的change_cipher_spec记录，则必须将其视为意外记录类型（尽管无状态服务器可能无法将这些情况与允许的情况区分开）。 除非通过某些扩展协商，否则实现绝不能发送本文档中未定义的记录类型。 如果TLS实现收到意外的记录类型，它必须使用“unexpected_message”警报终止连接。 新记录内容类型值由IANA在TLS ContentType注册表中分配，如第11节中所述。 


 Rescorla标准轨道[第77页] 
 
 RFC 8446 TLS 2018年8月



 5.1 。  记录层

记录层将信息块分段为携带2 ^ 14字节或更少字节块的数据的TLSPlaintext记录。 根据底层ContentType，消息边界的处理方式不同。 任何未来的内容类型必须指定适当的规则。 请注意，这些规则比TLS 1.2中强制执行的规则更严格。 

握手消息可以合并为单个TLSPlaintext记录，也可以分散在多个记录中，前提是： 

- 握手消息不得与其他记录类型交错。 也就是说，如果握手消息被分成两个或多个记录，则它们之间不能有任何其他记录。 

- 握手消息绝不能跨越密钥更改。 实现必须验证密钥更改之前的所有消息是否与记录边界对齐; 如果没有，那么他们必须用“unexpected_message”警报终止连接。 由于ClientHello，EndOfEarlyData，ServerHello，Finished和KeyUpdate消息可以紧接在密钥更改之前，因此实现必须将这些消息与记录边界对齐。 

实现绝不能发送握手类型的零长度片段，即使这些片段包含填充。 

警报消息（ 第6节 ）不得在记录之间进行分段，并且多条警报消息不得合并为单个TLSP文本记录。 换句话说，具有Alert类型的记录必须只包含一条消息。 

应用程序数据消息包含对TLS不透明的数据。 应用程序数据消息始终受到保护 可以发送应用程序数据的零长度片段，因为它们可能用作流量分析对策。 应用程序数据片段可以拆分为多个记录，也可以合并为一个记录。
 Rescorla Standards Track [第78页] 
 
 RFC 8446 TLS 2018年8月
枚举{ 
invalid（0），change_cipher_spec（20），alert（21），handshake（22），application_data（23），（255）} ContentType; 

struct {ContentType type; ProtocolVersion legacy_record_version; uint16长度; 不透明片段[TLSPlaintext.length]; 
TLSPlaintext; 

type：用于处理随附的高级协议 
分段。 

legacy_record_version：所有记录必须设置为0x0303 
由初始ClientHello之外的TLS 1.3实现生成的（即，在HelloRetryRequest之后未生成的实现），其中出于兼容性目的，它也可以是0x0301。 该字段已弃用，必须为所有目的忽略。 在某些情况下，以前版本的TLS将在此字段中使用其他值。 

length：以下内容的长度（以字节为单位） 
TLSPlaintext.fragment。 长度不得超过2 ^ 14字节。 接收超过此长度的记录的端点必须使用“record_overflow”警报终止连接。 

fragment：正在传输的数据。 这个值是透明的 
被视为一个独立的块，由类型字段指定的更高级协议处理。 

本文档描述了TLS 1.3，它使用版本0x0304。 此版本值是历史版本，源自对TLS 1.0使用0x0301和对SSL 3.0使用0x0300。 为了最大化向后兼容性，包含初始ClientHello的记录应该具有版本0x0301（反映TLS 1.0），包含第二个ClientHello或ServerHello的记录必须具有版本0x0303（反映TLS 1.2）。 在协商TLS的早期版本时，端点遵循附录D中提供的过程和要求。 当尚未使用记录保护时，TLSPlaintext结构将直接写入线路。 一旦记录保护开始，TLSPlaintext记录将受到保护并按照以下部分所述发送。 请注意，应用程序数据记录不得写入未受保护的电线（有关详细信息，请参阅第2节 ）。
 Rescorla Standards Track [第79页] 
 
 RFC 8446 TLS 2018年8月

 5.2 。  记录有效负载保护

记录保护功能将TLSPlaintext结构转换为TLSCiphertext结构。 脱保护功能使该过程逆转。 在TLS 1.3中，与先前版本的TLS相反，所有密码都被建模为“具有关联数据的认证加密”（AEAD） [RFC5116] 。 AEAD功能提供统一的加密和认证操作，将明文转换为经过认证的密文，然后再返回。 每个加密记录由一个明文标题后跟一个加密主体组成，该主体本身包含一个类型和可选的填充。 

struct { 
不透明内容[TLSPlaintext.length]; ContentType类型; uint8 zeros [length_of_padding]; } TLSInnerPlaintext; 

struct {ContentType opaque_type = application_data; / * 23 * / ProtocolVersion legacy_record_version = 0x0303; / * TLS v1.2 * / uint16 length; opaque encrypted_record [TLSCiphertext.length]; 
} TLSCiphertext; 

content：包含字节的TLSPlaintext.fragment值 
握手或警报消息的编码，或要发送的应用程序数据的原始字节。 

type：包含内容类型的TLSPlaintext.type值 
记录。 

零：可以出现任意长度的零值字节 
类型字段后的明文。 只要总数保持在记录大小限制范围内，这就为发件人提供了按所选金额填充任何TLS记录的机会。 更多详细信息，请参见第5.4节 。
 Rescorla Standards Track [第80页] 
 
 RFC 8446 TLS 2018年8月
opaque_type：TLSCiphertext记录的外部opaque_type字段 
始终设置为值23（application_data），以便与习惯于解析以前版本的TLS的中间件向外兼容。 解密后，在TLSInnerPlaintext.type中找到记录的实际内容类型。 

legacy_record_version：legacy_record_version字段始终为 
0x0303。 在协商TLS 1.3之后才生成TLS 1.3 TLSCiphertexts，因此没有历史兼容性问题可能会收到其他值。 请注意，握手协议（包括ClientHello和ServerHello消息）会对协议版本进行身份验证，因此该值是多余的。 

length：以下内容的长度（以字节为单位） 
TLSCiphertext.encrypted_record，它是内容和填充的长度之和，加上内容类型的一个，加上AEAD算法添加的任何扩展。 长度不得超过2 ^ 14 + 256字节。 接收超过此长度的记录的端点必须使用“record_overflow”警报终止连接。 

encrypted_record：序列化的AEAD加密形式 
TLSInnerPlaintext结构。 

AEAD算法将单个密钥，随机数，明文和要包含在认证检查中的“附加数据”作为输入，如[RFC5116]的第2.1节所述。 键是client_write_key或server_write_key，nonce是从序列号和client_write_iv或server_write_iv派生的（参见第5.3节 ），附加数据输入是记录头。 

也就是说， 
       additional_data = TLSCiphertext.opaque_type ||
                         TLSCiphertext.legacy_record_version ||
                         TLSCiphertext.length

输入AEAD算法的明文是编码的TLSInnerPlaintext结构。 第7.3节定义了流量密钥的派生。 

AEAD输出包括AEAD加密操作的密文输出。 由于包含TLSInnerPlaintext.type和发送方提供的任何填充，明文的长度大于相应的TLSPlaintext.length。 AEAD输出的长度通常大于明文，但是随着AEAD算法的变化而变化。 由于密码可能包含填充，因此开销量可能随着明文的不同长度而变化。 象征性的， 


 Rescorla标准轨道[第81页] 
 
 RFC 8446 TLS 2018年8月



AEADEncrypted = 
AEAD-Encrypt（write_key，nonce，additional_data，plaintext） 

TLSCiphertext的encrypted_record字段设置为AEADEncrypted。 

为了解密和验证，密码将密钥，随机数，附加数据和AEADE加密值作为输入。 输出是明文或表示解密失败的错误。 没有单独的完整性检查。 象征性的， 

加密_record =的明文 
AEAD-Decrypt（peer_write_key，nonce， 
additional_data，AEADEncrypted） 

如果解密失败，接收方必须使用“bad_record_mac”警报终止连接。 

TLS 1.3中使用的AEAD算法不得产生大于255个八位字节的扩展。 从TLSCiphertext.length大于2 ^ 14 + 256个八位字节的对等体接收记录的端点必须以“record_overflow”警报终止连接。 此限制源自ContentType的最大TLSInnerPlaintext长度2 ^ 14个八位字节+ 1个八位字节+ 255个八位字节的最大AEAD扩展。 
 5.3 。  Per-Record Nonce

分别维护64位序列号以读取和写入记录。 在读取或写入每个记录之后，适当的序列号加1。 每个序列号在连接开始时和每次更改密钥时都设置为零; 在特定流量密钥下传输的第一条记录必须使用序列号0。 

因为序列号的大小是64位，所以它们不应该换行。 如果TLS实现需要包装序列号，则必须重新生成（ 第4.6.3节 ）或终止连接。 每个AEAD算法将为每个记录的随机数指定一系列可能的长度，从N_MIN字节到输入的N_MAX字节[RFC5116] 。 对于AEAD算法，TLS每记录随机数（iv_length）的长度设置为8字节和N_MIN中的较大者（参见[RFC5116]，第4节 ）。 其中N_MAX小于8个字节的AEAD算法不得与TLS一起使用。 AEAD构造的每记录nonce形成如下：
 Rescorla标准跟踪[第82页] 
 
 RFC 8446 TLS 2018年8月

1. 64位记录序列号以网络字节顺序编码，并用零填充到iv_length。 

2.填充的序列号与静态client_write_iv或server_write_iv（取决于角色）进行异或。 

得到的数量（长度为iv_length）用作每记录的随机数。 

注意：这与TLS 1.2中的结构不同，后者指定了部分显式的随机数。 
 5.4 。  记录填充

可以填充所有加密的TLS记录以扩大TLSCiphertext的大小。 这允许发送者隐藏来自观察者的流量大小。 

生成TLSCiphertext记录时，实现可以选择填充。 未填充的记录只是填充长度为零的记录。 填充是在加密之前附加到ContentType字段的一串零值字节。 实现必须在加密之前将填充八位字节设置为全零。 

如果发送者需要，应用程序数据记录可以包含零长度的TLSInnerPlaintext.content。 这允许在活动的存在或不存在可能敏感的环境中产生合理大小的覆盖流量。 实现绝不能发送具有零长度TLSInnerPlaintext.content的握手和警报记录; 如果收到这样的消息，接收实现必须用“unexpected_message”警报终止连接。 发送的填充由记录保护机制自动验证; 在成功解密TLSCiphertext.encrypted_record后，接收实现从末端向开始扫描字段，直到找到非零八位字节为止。 该非零八位字节是消息的内容类型。 选择此填充方案是因为它允许以任意大小（从零到TLS记录大小限制）填充任何加密的TLS记录，而不引入新的内容类型。 该设计还强制实施全零填充八位字节，以便快速检测填充错误。
 Rescorla标准跟踪[第83页] 
 
 RFC 8446 TLS 2018年8月

实现必须将扫描限制为从AEAD解密返回的明文。 如果接收实现在明文中没有找到非零八位字节，它必须使用“unexpected_message”警报终止连接。 

填充的存在不会改变整体记录大小限制：完整编码的TLSInnerPlaintext不得超过2 ^ 14 + 1个八位字节。 如果最大片段长度减小 - 例如，来自[RFC8449]的record_size_limit扩展 - 那么减少的限制适用于完整的纯文本，包括内容类型和填充。 

选择建议填充时间和填充量的填充策略是一个复杂的主题，超出了本规范的范围。 如果TLS之上的应用层协议具有自己的填充，则最好在应用层内填充应用数据TLS记录。 但是，加密握手或警报记录的填充仍必须在TLS层处理。 稍后的文档可以定义填充选择算法或通过TLS扩展或一些其他手段定义填充策略请求机制。 
 5.5 。  密钥使用限制

明文数量存在加密限制，可以在给定的一组密钥下安全加密。 [AEAD-LIMITS]在假设基础原语（AES或ChaCha20）没有弱点的情况下提供了对这些限制的分析。 在达到这些限制之前，实现应该按照第4.6.3节中的描述进行密钥更新。 

对于AES-GCM，在给定连接上可以加密多达2 ^ 24.5个全尺寸记录（大约2400万个），同时为认证加密（AE）安全性保持大约2 ^ -57的安全裕度。 对于ChaCha20 / Poly1305，记录序列号将在达到安全限制之前换行。 




 Rescorla标准轨道[第84页] 
 
 RFC 8446 TLS 2018年8月


6 。 警报协议 

TLS提供Alert内容类型以指示关闭信息和错误。 与其他消息一样，警报消息按当前连接状态的指定进行加密。 

警报消息传达警报的描述以及在先前版本的TLS中传达消息严重性级别的遗留字段。 警报分为两类：关闭警报和错误警报。 在TLS 1.3中，严重性隐含在正在发送的警报类型中，并且可以安全地忽略“级别”字段。 “close_notify”警报用于指示连接的一个方向的有序关闭。 收到此类警报后，TLS实现应该指示应用程序的数据结束。 

错误警报表示连接中断（参见第6.2节 ）。 收到错误警报后，TLS实现应该向应用程序指示错误，并且不允许在连接上发送或接收任何其他数据。 服务器和客户端必须忘记在失败的连接中建立的秘密值和密钥，但与会话票据关联的PSK除外，如果可能，应该丢弃它们。 

第6.2节中列出的所有警报必须与AlertLevel =致命一起发送，并且在收到时必须被视为错误警报，而不管消息中的AlertLevel如何。 未知的警报类型必须被视为错误警报。 

注意：TLS定义了两个通用警报（请参阅第6节 ），以便在解析消息失败时使用。 接收根据语法无法解析的消息的对等方（例如，具有超出消息边界的长度或包含超出范围的长度）必须使用“decode_error”警报终止连接。 接收语法正确但语义无效的消息（例如，p-1的DHE共享或无效枚举）的对等方必须使用“illegal_parameter”警报终止连接。 enum {warning（1），fatal（2），（255）} AlertLevel;
 Rescorla Standards Track [第85页] 
 
 RFC 8446 TLS 2018年8月

枚举{close_notify（0），unexpected_message（10），bad_record_mac（20），record_overflow（22），handshake_failure（40），bad_certificate（42），unsupported_certificate（43），certificate_revoked（44），certificate_expired（45），certificate_unknown（46） ），illegal_parameter（47），unknown_ca（48），access_denied（49），decode_error（50），decrypt_error（51），protocol_version（70），insufficient_security（71），internal_error（80）,appropriate_fallback（86），user_canceled（90） ），missing_extension（109），unsupported_extension（110），unrecognized_name（112），bad_certificate_status_response（113），unknown_psk_identity（115），certificate_required（116），no_application_protocol（120），（255）} AlertDescription; 

struct {AlertLevel level; AlertDescription描述; 
警报;
 Rescorla标准轨道[第86页] 
 
 RFC 8446 TLS 2018年8月
 6.1 。  关闭警报

客户端和服务器必须共享连接结束的知识，以避免截断攻击。 

close_notify：此警报通知收件人发件人不会再在此连接上发送任何邮件。 收到关闭警报后收到的任何数据都必须被忽略。 

user_canceled：此警报通知收件人发件人是 
由于与协议故障无关的某些原因取消握手。 如果用户在握手完成后取消操作，则通过发送“close_notify”来关闭连接更为合适。 这个警告应该跟一个“close_notify”。 此警报通常具有AlertLevel =警告。 

任何一方都可以通过发送“close_notify”警报来启动其连接写入端的关闭。 收到关闭警报后收到的任何数据都必须被忽略。 如果在“close_notify”之前接收到传输级别关闭，则接收方不能知道已经接收到所有已发送的数据。 

除非已经发送了一些错误警告，否则每一方必须在关闭连接的写入端之前发送“close_notify”警报。 这对连接的读取端没有任何影响。 请注意，这是对TLS 1.3之前的TLS版本的更改，其中要求实现通过丢弃挂起的写入并立即发送他们自己的“close_notify”警报来响应“close_notify”。 之前的要求可能会导致读取方面的截断。 在关闭连接的读取端之前，双方都不需要等待接收“close_notify”警报，但这样做会引入截断的可能性。 

如果使用TLS的应用程序协议规定在TLS连接关闭后可以通过底层传输承载任何数据，则TLS实现必须在指示应用层的数据结束之前收到“close_notify”警报。 不应采用此标准的任何部分来规定TLS的使用配置文件管理其数据传输的方式，包括何时打开或关闭连接。 

注意：假设在销毁传输之前关闭连接的写入端可靠地传递未决数据。
 Rescorla Standards Track [第87页] 
 
 RFC 8446 TLS 2018年8月
 6.2 。  错误提醒

TLS中的错误处理非常简单。 当检测到错误时，检测方向其对等方发送消息。 在传输或收到致命警报消息时，双方必须立即关闭连接。 

每当实现遇到致命错误情况时，它应该发送适当的致命警报并且必须关闭连接而不发送或接收任何其他数据。 在本规范的其余部分中，当使用短语“终止连接”和“中止握手”而没有特定警报时，这意味着实现应该发送由以下描述指示的警报。 短语“使用X警报终止连接”和“使用X警报中止握手”意味着如果发送任何警报，则实施必须发送警报X. 从TLS 1.3开始，本节下面定义的所有警报以及所有未知警报都被认为是致命的（参见第6节 ）。 实现应该提供一种方便日志记录发送和接收警报的方法。 

定义了以下错误警报： 

unexpected_message：收到不适当的消息（例如，错误的握手消息，过早的应用程序数据等）。 在正确实现之间的通信中永远不应该观察到此警报。 

bad_record_mac：如果收到记录，则返回此警报 
不能脱保护。 由于AEAD算法结合了解密和验证，并且还避免了侧通道攻击，因此该警报用于所有脱保护失败。 除非网络中的邮件已损坏，否则在正确实施之间的通信中绝不应遵守此警报。 

record_overflow：收到了一个有TLSCiphertext记录 
长度大于2 ^ 14 + 256字节，或者解密为TLSPlaintext记录的记录超过2 ^ 14字节（或其他一些协商限制）。 除非网络中的邮件已损坏，否则在正确实施之间的通信中绝不应遵守此警报。 

handshake_failure：收到“handshake_failure”警报消息 
表示在给定可用选项的情况下，发件人无法协商一组可接受的安全参数。 

bad_certificate：证书已损坏，包含签名 
没有正确验证等 


 Rescorla Standards Track [第88页] 
 
 RFC 8446 TLS 2018年8月


unsupported_certificate：证书类型不受支持。 

certificate_revoked：证书已由其签名者撤销。 

certificate_expired：证书已过期或当前不存在 
有效。 

certificate_unknown：出现了一些其他（未指明的）问题 
处理证书，使其无法接受。 

illegal_parameter：握手中的字段不正确或 
与其他领域不一致。 此警报用于符合正式协议语法但其他方面不正确的错误。 

unknown_ca：收到有效的证书链或部分链， 
但未接受证书，因为无法找到CA证书或无法与已知的信任锚匹配。 

access_denied：收到了有效的证书或PSK，但是何时收到 
应用了访问控制，发件人决定不进行协商。 

decode_error：无法解码消息，因为某些字段是 
超出指定范围或消息长度不正确。 此警报用于消息不符合正式协议语法的错误。 除非网络中的邮件已损坏，否则在正确实施之间的通信中绝不应遵守此警报。 

decrypt_error：握手（不是记录层）加密 
操作失败，包括无法正确验证签名或验证完成邮件或PSK活页夹。 

protocol_version：对等方尝试的协议版本 
谈判得到承认但不受支持（见附录D ）。 

insufficient_security：当返回时返回而不是“handshake_failure” 
协商失败是因为服务器需要的参数比客户端支持的参数更安全。 

internal_error：与对等或无关的内部错误 
协议的正确性（例如内存分配失败）使得无法继续。 

applicable_fallback：由服务器发送以响应无效 
来自客户端的连接重试尝试（参见[ RFC7507 ]）。 


 Rescorla标准轨道[第89页] 
 
 RFC 8446 TLS 2018年8月


missing_extension：由接收握手的端点发送 
消息不包含必须为提供的TLS版本或其他协商参数发送的扩展名。 

unsupported_extension：由接收任何握手的端点发送 
包含已知禁止包含在给定握手消息中的扩展名的消息，或包含ServerHello或证书中未在相应ClientHello或CertificateRequest中首先提供的任何扩展名的消息。 

unrecognized_name：当没有标识服务器时由服务器发送 
由客户端通过“server_name”扩展名提供的名称（参见[RFC6066] ）。 

bad_certificate_status_response：客户端在无效或发送时发送 
服务器通过“status_request”扩展提供不可接受的OCSP响应（参见[RFC6066] ）。 

unknown_psk_identity：PSK密钥建立时由服务器发送 
期望但客户不提供可接受的PSK身份。 发送此警报是可选的; 服务器可以选择发送“decrypt_error”警报，仅指示无效的PSK身份。 

certificate_required：客户端证书所在的服务器发送 
期望但没有一个是由客户提供的。 

no_application_protocol：客户端由服务器发送 
“application_layer_protocol_negotiation”扩展仅通告服务器不支持的协议（请参阅[RFC7301] ）。 

新警报值由IANA分配，如第11节所述。 

7 。 密码计算 

TLS握手建立一个或多个输入秘密，这些输入秘密被组合以创建实际的工作密钥材料，如下所述。 密钥派生过程包含输入密钥和握手记录。 请注意，由于握手记录包含来自Hello消息的随机值，因此即使使用相同的输入密钥，任何给定的握手也将具有不同的流量机密，就像将相同的PSK用于多个连接的情况一样。
 Rescorla Standards Track [第90页] 
   RFC 8446 TLS 2018年8月 7.1 。  关键时间表 
密钥派生过程使用HKDF [RFC5869]定义的HKDF -Extract和HKDF-Expand函数，以及下面定义的函数： 

HKDF-Expand-Label（秘密，标签，背景，长度）= 
HKDF-Expand（秘密，HkdfLabel，长度） 

其中HkdfLabel指定为： 

struct {uint16 length = Length; 不透明标签<7..255> =“tls13”+标签; opaque context <0..255> = Context; HkdfLabel; 

Derive-Secret（秘密，标签，消息）= 
HKDF-Expand-Label（秘密，标签， 
Transcript-Hash（Messages），Hash.length） 

Transcript-Hash和HKDF使用的Hash函数是密码套件哈希算法。 Hash.length是其输出长度（以字节为单位）。 消息是指示的握手消息的串联，包括握手消息类型和长度字段，但不包括记录层头。 请注意，在某些情况下，零长度上下文（由“”表示）传递给HKDF-Expand-Label。 本文档中指定的标签都是ASCII字符串，不包括尾随NUL字节。 

注意：对于常见的哈希函数，任何超过12个字符的标签都需要额外迭代哈希函数来进行计算。 所有标准都已选择符合此限制。 密钥使用HKDF-Extract和Derive-Secret函数从两个输入密钥派生。 添加新秘密的一般模式是使用HKDF-Extract，其中Salt是当前的秘密状态，输入密钥材料（IKM）是要添加的新秘密。 在此版本的TLS 1.3中，两个输入密钥是：
 Rescorla Standards Track [第91页] 
 
 RFC 8446 TLS 2018年8月

- PSK（外部建立的预共享密钥或从先前连接的resumption_master_secret值派生的） 

- （EC）DHE共享秘密（ 第7.4节 ） 

这将生成一个完整的密钥推导计划，如下图所示。 在此图中，以下格式约定适用： 

- HKDF-Extract绘制为从顶部获取Salt参数，从左侧获取IKM参数，其输出显示在底部，输出名称在右侧。 

- Derive-Secret的秘密参数由传入的箭头指示。 例如，早期秘密是生成client_early_traffic_secret的秘密。 

- “0”表示将Hash.length字节的字符串设置为零。
 Rescorla Standards Track [第92页] 
 
 RFC 8446 TLS 2018年8月
              0
              |
              v
    PSK  - > HKDF-Extract =早期秘密
              |
              + -----> Derive-Secret（。，“ext binder”|“res binder”，“”）
              |  = binder_key
              |
              + -----> Derive-Secret（。，“ce traffic”，ClientHello）
              |  = client_early_traffic_secret
              |
              + -----> Derive-Secret（。，“e exp master”，ClientHello）
              |  = early_exporter_master_secret
v
        Derive-Secret（。，“衍生”，“”）
              |
              v
    （EC）DHE  - > HKDF-Extract = Handshake Secret
              |
              + -----> Derive-Secret（。，“c hs traffic”，
              | 客户问候...服务器问候）
              |  = client_handshake_traffic_secret
              |
              + -----> Derive-Secret（。，“s hs traffic”，
              | 客户问候...服务器问候）
| = server_handshake_traffic_secret v
        Derive-Secret（。，“衍生”，“”）
              |
              v
    0  - > HKDF-Extract = Master Secret
              |
              + -----> Derive-Secret（。，“c ap traffic”，
              |  ClientHello ...服务器已完成）
              |  = client_application_traffic_secret_0
              |
              + -----> Derive-Secret（。，“s ap traffic”，
              |  ClientHello ...服务器已完成）
              |  = server_application_traffic_secret_0
              |
              + -----> Derive-Secret（。，“exp master”，
              |  ClientHello ...服务器已完成）
              |  = exporter_master_secret
              |
              + -----> Derive-Secret（。，“res master”，
                                    ClientHello ...客户端已完成）
= resumption_master_secret 



 Rescorla标准轨道[第93页] 
 
 RFC 8446 TLS 2018年8月


这里的一般模式是图左侧显示的秘密只是没有上下文的原始熵，而右侧的秘密包括握手上下文，因此可以用来派生工作密钥而无需额外的上下文。 请注意，对Derive-Secret的不同调用可能会使用不同的Messages参数，即使具有相同的秘密。 在0-RTT交换中，Derive-Secret被调用四个不同的抄本; 在1-RTT-only交换中，它被称为三个不同的转录本。 

如果给定的秘密不可用，则使用由设置为零的Hash.length字节串组成的0值。 请注意，这并不意味着跳过轮次，因此如果不使用PSK，早期秘密仍将是HKDF-Extract（0,0）。 对于binder_key的计算，标签是外部PSK（在TLS之外提供的那些）的“ext binder”和用于恢复PSK的“res binder”（提供为先前握手的恢复主秘密的那些）。 不同的标签阻止了一种PSK替代另一种PSK。 

有多个潜在的早期秘密值，具体取决于服务器最终选择的PSK。 客户端需要为每个潜在的PSK计算一个; 如果没有选择PSK，则需要计算对应于零PSK的早期秘密。 

一旦计算出从给定秘密导出的所有值，就应该删除该秘密。 
 7.2 。  更新交通秘密

握手完成后，任何一方都可以使用第4.6.3节中定义的KeyUpdate握手消息更新其发送流量密钥。 下一代流量密钥的计算方法是，如本节所述，从client_ / server_application_traffic_secret_N生成client_ / server_application_traffic_secret_N + 1，然后按第7.3节所述重新导出流量密钥。 

下一代application_traffic_secret计算如下： 

application_traffic_secret_N + 1 = 
香港民主促进会展开标签（application_traffic_secret_N， 
“traffic upd”，“”，Hash.length） 

一旦计算了client_ / server_application_traffic_secret_N + 1及其关联的流量密钥，实现应该删除client_ / server_application_traffic_secret_N及其关联的流量密钥。 



 Rescorla Standards Track [第94页] 
 
 RFC 8446 TLS 2018年8月


 7.3 。  交通密钥计算

流量密钥材料由以下输入值生成： 

- 秘密价值 

- 表示正在生成的特定值的目的值 

- 生成密钥的长度 

使用以下内容从输入流量秘密值生成流量密钥材料： 

[sender] _write_key = HKDF-Expand-Label（Secret，“key”，“”，key_length） [sender] _write_iv = HKDF-Expand-Label（Secret，“iv”，“”，iv_length） 

[sender]表示发送方。 每种记录类型的Secret值显示在下表中。 
        + ------------------- + ----------------------------- ---------- +
        | 记录类型| 秘密|
        + ------------------- + ----------------------------- ---------- +
        |  0-RTT应用程序|  client_early_traffic_secret |
        |  |  |
        | 握手|  [ 发送者 ] _handshake_traffic_secret |
        |  |  |
        | 应用数据|  [ sender ] _application_traffic_secret_N |
        + ------------------- + ----------------------------- ---------- +

每当基础秘密改变时（例如，当从握手改变为应用数据密钥或密钥更新时），重新计算所有流量密钥材料。 
 7.4 。  （EC）DHE共享秘密计算

 7.4.1 。  有限域Diffie-Hellman

对于有限场组，执行传统的Diffie-Hellman [DH76]计算。 协商密钥（Z）通过以big-endian形式编码转换为字节串，并用零填充左边填充到素数的大小。 此字节字符串用作密钥计划中的共享密钥，如上所述。 

请注意，此结构与先前版本的TLS不同，后者删除了前导零。 




 Rescorla Standards Track [第95页] 
 
 RFC 8446 TLS 2018年8月


 7.4.2 。  椭圆曲线Diffie-Hellman

对于secp256r1，secp384r1和secp521r1，根据[IEEE1363]使用ECKAS-DH1方案执行ECDH计算（包括参数和密钥生成以及共享秘密计算），并将身份图作为密钥导出函数（KDF），因此，共享秘密是表示为八位字节串的ECDH共享秘密椭圆曲线点的x坐标。 注意，FE2OSP（字段元素到八位字符串转换基元）输出的该八位字符串（IEEE 1363术语中的“Z”）对于任何给定字段具有恒定长度; 在此八位字符串中找到的前导零不得截断。 

（请注意，使用身份KDF是一种技术性。完整的图片是ECDH与非平凡的KDF一起使用，因为TLS不直接将此秘密用于计算其他秘密以外的任何其他内容。） 

对于X25519和X448，ECDH计算如下： 

- 放入KeyShareEntry.key_exchange结构的公钥是将ECDH标量乘法函数应用于适当长度（标量输入）和标准公共基点（进入u坐标点输入）的密钥的结果。 

- ECDH共享密钥是将ECDH标量乘法函数应用于密钥（进入标量输入）和对等方的公钥（进入u坐标点输入）的结果。 输出原始使用，无需处理。 

对于这些曲线，实现应该使用[RFC7748]中指定的方法来计算Diffie-Hellman共享密钥。 实现必须检查计算的Diffie-Hellman共享密钥是否为全零值，如果是，则中止，如[RFC7748]的第6节所述。 如果实现者使用这些椭圆曲线的替代实现，则他们应该执行[RFC7748]第7节中指定的附加检查。
 Rescorla Standards Track [第96页] 
 
 RFC 8446 TLS 2018年8月
 7.5 。  出口商

[RFC5705]根据TLS伪随机函数（PRF）定义TLS的密钥材料导出器。 本文件用HKDF取代PRF，因此需要新的结构。 导出器界面保持不变。 

导出器值计算如下： 

TLS-Exporter（label，context_value，key_length）= 
HKDF-Expand-Label（Derive-Secret（秘密，标签，“”）， 
“exporter”，Hash（context_value），key_length） 

Secret是early_exporter_master_secret或exporter_master_secret。 除非应用程序明确指定，否则实现必须使用exporter_master_secret。 early_exporter_master_secret定义为在0-RTT数据需要导出器的设置中使用。 建议为早期出口商提供单独的界面; 这可以避免出口商用户在需要常规出口商时意外使用早期出口商，反之亦然。 

如果未提供上下文，则context_value为零长度。 因此，不提供上下文计算与提供空上下文相同的值。 这是对以前版本的TLS的更改，其中空上下文产生的输出与不存在的上下文不同。 截至本文档的出版物，无论是否使用上下文，都不会使用已分配的导出器标签。 未来的规范绝不能定义允许空上下文和没有相同标签的上下文的导出器的使用。 出口商的新用途应该在所有出口商计算中提供上下文，尽管价值可能是空的。 

出口商标签格式的要求在[RFC5705]的第4节中定义。
 Rescorla标准轨道[页97] 
 
 RFC 8446 TLS 2018年8月

8 。 0-RTT和反重播 

如第2.3节和附录E.5所述 ，TLS不为0-RTT数据提供固有的重放保护。 有两个潜在的威胁需要关注： 

- 通过简单地复制0-RTT数据的航班来发起重放攻击的网络攻击者。 

- 利用客户端重试行为安排服务器接收应用程序消息的多个副本的网络攻击者。 这种威胁在某种程度上已经存在，因为重视健壮性的客户端通过尝试重试请求来响应网络错误。 但是，0-RTT为任何不维护全局一致服务器状态的服务器系统添加了额外的维度。 具体来说，如果服务器系统有多个区域，区域B中不接受来自区域A的票证，则攻击者可以将A和B的ClientHello和早期数据复制到A和A.A，数据将被接受0-RTT，但在B，服务器将拒绝0-RTT数据，而是强制进行完全握手。 如果攻击者从A阻止ServerHello，则客户端将完成与B的握手并可能重试该请求，从而导致整个服务器系统上的重复。 

通过共享状态可以防止第一类攻击，以保证最多一次接受0-RTT数据。 服务器应该通过实现本节中描述的方法之一或通过等效方法提供该级别的重放安全性。 但是，据了解，由于操作问题，并非所有部署都将维持该级别的状态。 因此，在正常操作中，客户端将不知道这些机制服务器实际上实现了哪些（如果有的话），因此必须只发送他们认为可以安全重放的早期数据。 

除了重放的直接影响之外，还存在一类攻击，即使通常被认为是幂等的操作也可以通过大量重放（定时攻击，资源限制耗尽等，如附录E.5中所述 ）来利用。 可以通过确保每个0-RTT有效载荷只能重播有限次数来减轻这些问题。 服务器必须确保它的任何实例（无论是机器，线程还是相关服务基础架构内的任何其他实体）都会接受0-RTT，最多只能进行一次0-RTT握手; 这会将重放次数限制为部署中的服务器实例数。 这种保证可以通过从最近接收的ClientHellos本地记录数据并拒绝重复，或通过提供相同或更强保证的任何其他方法来完成。 “每个服务器实例最多一次”保证是最低要求; 服务器应该在可行的情况下进一步限制0-RTT重放。 



 Rescorla标准轨道[第98页] 
 
 RFC 8446 TLS 2018年8月



在TLS层无法阻止第二类攻击，必须由任何应用程序处理。 请注意，客户端实现任何类型的重试行为的任何应用程序都需要实现某种反重放防御。 
 8.1 。  一次性门票

最简单的防重放防御形式是服务器只允许使用一次会话票证。 例如，服务器可以维护所有未完成有效票证的数据库，在使用时从数据库中删除每个票证。 如果提供了未知票证，则服务器将回退到完全握手。 

如果票证不是自包含的而是数据库密钥，并且在使用时删除相应的PSK，则使用PSK建立的连接享有前向保密。 当在没有（EC）DHE的情况下使用PSK时，这提高了所有0-RTT数据和PSK使用的安全性。

由于此机制要求在具有多个分布式服务器的环境中的服务器节点之间共享会话数据库，因此与自加密票证相比，可能难以实现成功的PSK 0-RTT连接的高速率。 与会话数据库不同，即使没有一致的存储，会话票证也可以成功地进行基于PSK的会话建立，但是当允许0-RTT时，它们仍然需要一致的存储来反重放0-RTT数据，如下节所述。 
 8.2 。  客户端Hello录制

另一种反重放形式是记录从ClientHello派生的唯一值（通常是随机值或PSK活页夹）并拒绝重复。 记录所有ClientHellos会导致状态无限制地增长，但服务器可以在给定时间窗口内记录ClientHellos并使用“obfuscated_ticket_age”来确保不在该窗口外重用票证。 

为了实现这一点，当收到ClientHello时，服务器首先验证PSK绑定器，如4.2.11节所述。 然后，它将按照下一节中的描述计算expected_arrival_time，如果它在记录窗口之外，则拒绝0-RTT，然后回退到1-RTT握手。 如果expected_arrival_time在窗口中，则服务器检查它是否记录了匹配的ClientHello。 如果找到一个，它将使用“illegal_parameter”警报中止握手或接受PSK但拒绝0-RTT。 如果找不到匹配的ClientHello，则它接受0-RTT，然后只要expected_arrival_time在窗口内，就存储ClientHello。 服务器也可以实现具有误报的数据存储，例如布隆过滤器，在这种情况下，它们必须通过拒绝0-RTT来响应明显的重放，但绝不能中止握手。 




 Rescorla标准轨道[第99页] 
 
 RFC 8446 TLS 2018年8月



服务器必须仅从ClientHello的有效部分派生存储密钥。 如果ClientHello包含多个PSK标识，则攻击者可以创建多个具有不同绑定器值的ClientHellos，用于不太优选的标识，前提是服务器不会对其进行验证（如第4.2.11节所述 ）。 即，如果客户端发送PSK A和B但服务器更喜欢A，则攻击者可以更改B的绑定器而不影响A的绑定器。如果B的绑定器是存储键的一部分，则此ClientHello将不会出现作为重复，这将导致ClientHello被接受，并且可能导致副作用，例如重放缓存污染，尽管任何0-RTT数据都不会被解密，因为它将使用不同的密钥。 如果使用经过验证的绑定程序或ClientHello.random作为存储密钥，则无法进行此攻击。 

因为这种机制不需要存储所有未完成的票据，所以在具有高恢复率和0-RTT的分布式系统中实现可能更容易，代价是可能较弱的反重放防御，因为难以可靠地存储和检索收到ClientHello消息。 在许多这样的系统中，对所有接收的ClientHellos进行全局一致的存储是不切实际的。 在这种情况下，通过使单个存储区域对给定票证具有权威性并拒绝任何其他区域中的该票证的0-RTT来提供最佳防重放保护。 此方法可防止攻击者进行简单重放，因为只有一个区域可接受0-RTT数据。 较弱的设计是为每个区域实现单独存储，但允许在任何区域中使用0-RTT。 此方法将每个区域的重放次数限制为一次。 当然，任何一种设计都可以实现应用程序消息重复。 

当实现刚刚开始时，只要其记录窗口的任何部分与启动时间重叠，它们就应该拒绝0-RTT。 否则，他们冒着接受最初在此期间发送的重放的风险。 注意：如果客户端的时钟运行速度比服务器的速度快得多，则可能会在将来接收到窗口外的ClientHello，在这种情况下，可能会接受1-RTT，导致客户端重试，然后可以接受对于0-RTT。 这是第8节中描述的第二种攻击形式的另一种变体。
 Rescorla标准跟踪[第100页] 
 
 RFC 8446 TLS 2018年8月

 8.3 。  新鲜度检查

因为ClientHello指示客户端发送它的时间，所以可以有效地确定ClientHello是否可能最近合理地发送并且仅接受这样的ClientHello的0-RTT，否则回退到1-RTT握手。 这对于8.2节中描述的ClientHello存储机制是必要的，因为否则服务器需要存储无限数量的ClientHellos，并且对于自包含的一次性票证是有用的优化，因为它允许有效拒绝不能用于ClientHellos的ClientHellos 0-RTT。 

为了实现这种机制，服务器需要存储服务器生成会话票据的时间，并通过估计客户端和服务器之间的往返时间来抵消。 也就是说， 

adjusted_creation_time = creation_time + estimated_RTT 

该值可以在票证中编码，从而避免为每个未完成的票证保持状态。 服务器可以通过从客户端的“pre_shared_key”扩展名中的“obfuscated_ticket_age”参数中减去故障单的“ticket_age_add”值来确定客户端的故障单年龄视图。 服务器可以将ClientHello的expected_arrival_time确定为： 

expected_arrival_time = adjusted_creation_time + clients_ticket_age 

当收到新的ClientHello时，expect_arrival_time然后与当前服务器挂钟时间进行比较，如果它们相差超过一定量，则拒绝0-RTT，尽管可以允许完成1-RTT握手。 有几种潜在的错误来源可能会导致expected_arrival_time和测量时间不匹配。 客户端和服务器时钟速率的变化可能是最小的，但可能绝对时间可能会被大值关闭。 网络传播延迟是经过时间合法值不匹配的最可能原因。 NewSessionTicket和ClientHello消息都可能被重新传输并因此被延迟，这可能被TCP隐藏。 对于互联网上的客户来说，这意味着大约10秒的窗口可以解决时钟错误和测量结果的变化; 其他部署方案可能有不同的需求。 时钟偏差分布不是对称的，因此最佳权衡可能涉及允许的不匹配值的不对称范围。
 Rescorla标准轨道[第101页] 
 
 RFC 8446 TLS 2018年8月

请注意，单独的新鲜度检查不足以防止重放，因为它在错误窗口期间未检测到它们，这取决于带宽和系统容量，可能包括实际环境中的数十亿次重放。 此外，此新鲜度检查仅在收到ClientHello时完成，而不是在收到后续早期应用程序数据记录时完成。 在接受早期数据之后，记录可以继续在较长时间段内流式传输到服务器。 


9 。 合规要求 
 9.1 。  强制实施密码套件

如果没有应用程序配置文件标准，则另行指定： 

符合TLS的应用程序必须实现TLS_AES_128_GCM_SHA256 [GCM]密码套件，并且应该实现TLS_AES_256_GCM_SHA384 [GCM]和TLS_CHACHA20_POLY1305_SHA256 [RFC8439]密码套件（参见附录B.4 ）。 

符合TLS的应用程序必须支持rsa_pkcs1_sha256（用于证书），rsa_pss_rsae_sha256（用于CertificateVerify和证书）和ecdsa_secp256r1_sha256的数字签名。 符合TLS的应用程序必须支持与secp256r1（NIST P-256）的密钥交换，并且应该支持与X25519 [RFC7748]的密钥交换。
 Rescorla Standards Track [第102页] 
   RFC 8446 TLS 2018年8月 9.2 。  强制执行扩展 
如果没有另外指定的应用程序配置文件标准，符合TLS的应用程序必须实现以下TLS扩展： 

- 支持的版本（“supported_versions”; 第4.2.1节 ） 

- Cookie（“cookie”; 第4.2.2节 ） 

- 签名算法（“signature_algorithms”; 第4.2.3节 ） 

- 签名算法证书（“signature_algorithms_cert”; 第4.2.3节 ） 

- 谈判组（“supported_groups”; 第4.2.7节 ） 

- 密钥共享（“key_share”; 第4.2.8节 ） 

- 服务器名称指示（“server_name”; [RFC6066]的第3节 ） 

在提供适用的功能时，所有实现都必须发送和使用这些扩展： 

- 所有ClientHello，ServerHello和HelloRetryRequest消息都需要“supported_versions”。 

- 证书认证需要“signature_algorithms”。 

- 对于使用DHE或ECDHE密钥交换的ClientHello消息，“supported_groups”是必需的。 

- DHE或ECDHE密钥交换需要“key_share”。 

- 对于PSK密钥协议，“pre_shared_key”是必需的。 

- 对于PSK密钥协议，“psk_key_exchange_modes”是必需的。 如果ClientHello包含一个包含在其正文中的0x0304的“supported_versions”扩展名，则客户端被视为尝试使用此规范进行协商。 这样的ClientHello消息必须满足以下要求：
 Rescorla Standards Track [第103页] 
 
 RFC 8446 TLS 2018年8月

- 如果不包含“pre_shared_key”扩展名，则它必须包含“signature_algorithms”扩展名和“supported_groups”扩展名。 

- 如果包含“supported_groups”扩展名，则它必须还包含“key_share”扩展名，反之亦然。 允许空的KeyShare.client_shares向量。 

接收不符合这些要求的ClientHello的服务器必须使用“missing_extension”警报中止握手。 

此外，所有实现必须支持使用能够使用它的应用程序的“server_name”扩展。 服务器可能要求客户端发送有效的“server_name”扩展名。 需要此扩展的服务器应该通过终止具有“missing_extension”警报的连接来响应缺少“server_name”扩展的ClientHello。 
 9.3 。  协议不变量

本节介绍TLS端点和中间件必须遵循的不变量。 它也适用于早期版本的TLS。 

TLS旨在安全且兼容地扩展。 较新的客户端或服务器在与较新的对等端通信时，应协商最优选的公共参数。 TLS握手提供降级保护：中间盒在较新的客户端和较新的服务器之间传递流量而不终止TLS应该无法影响握手（参见附录E.1 ）。 同时，部署以不同的速率更新，因此较新的客户端或服务器可以继续支持较旧的参数，这将允许它与较旧的端点进行互操作。 为此，实现必须正确处理可扩展字段：
 Rescorla Standards Track [第104页] 
 
 RFC 8446 TLS 2018年8月

- 发送ClientHello的客户端必须支持其中公布的所有参数。 否则，服务器可能无法通过选择其中一个参数来进行互操作。 

- 接收ClientHello的服务器必须正确地忽略所有无法识别的密码套件，扩展和其他参数。 否则，它可能无法与较新的客户端互操作。 在TLS 1.3中，接收CertificateRequest或NewSessionTicket的客户端也必须忽略所有无法识别的扩展。 

- 终止TLS连接的中间件必须表现为兼容的TLS服务器（对原始客户端），包括具有客户端愿意接受的证书，以及兼容的TLS客户端（到原始服务器），包括验证原始服务器的证书。 特别是，它必须生成自己的ClientHello，其中只包含它理解的参数，它必须生成一个新的ServerHello随机值，而不是转发端点的值。 

请注意，TLS的协议要求和安全性分析仅适用于两个连接。 安全地部署TLS终结器需要额外的安全注意事项，这超出了本文档的范围。 

- 转发ClientHello参数的中间件，它不理解绝不能处理ClientHello之外的任何消息。 它必须转发未经修改的所有后续流量。 否则，它可能无法与较新的客户端和服务器互操作。 

转发的ClientHellos可能包含中间件不支持的功能的广告，因此响应可能包括中间件无法识别的未来TLS添加。 这些添加可以任意改变ClientHello之外的任何消息。 特别是，ServerHello中发送的值可能会更改，ServerHello格式可能会更改，并且TLSCiphertext格式可能会更改。 

TLS 1.3的设计受到广泛部署的不合规TLS中间盒的限制（见附录D.4 ）; 但是，它不会放松不变量。 那些中间盒继续不合规。
 Rescorla Standards Track [第105页] 
 
 RFC 8446 TLS 2018年8月

10 。 安全考虑因素 

本备忘录中讨论了安全问题，特别是在附录C，D和E中。 


11 。 IANA注意事项 

本文档使用最初在[RFC4346]中创建并在[RFC8447]中更新的几个注册表。 IANA已更新这些内容以参考此文档。 注册管理机构及其分配政策如下： 

- TLS Cipher Suites注册表：通过Specification Required [RFC8126]分配0-254（十进制）范围内第一个字节的值。 第一个字节255（十进制）的值保留给专用[RFC8126] 。 

IANA已将附录B.4中列出的密码套件添加到注册表中。 “值”和“描述”列取自表中。 对于每个新的密码套件，“DTLS-OK”和“推荐”列都标记为“Y”。 

- TLS ContentType注册表：未来值通过Standards Action [RFC8126]分配。 

- TLS警报注册表：未来值通过标准操作[RFC8126]进行分配。 IANA已使用附录B.2中的值填充此注册表。 对于所有这些值，“DTLS-OK”列标记为“Y”。 标记为“_RESERVED”的值具有描述其先前用法的注释。 

- TLS HandshakeType注册表：未来值通过Standards Action [RFC8126]分配。 IANA已更新此注册表以将项目4从“NewSessionTicket”重命名为“new_session_ticket”，并使用附录B.3中的值填充此注册表。 对于所有这些值，“DTLS-OK”列标记为“Y”。 标记为“_RESERVED”的值具有描述其先前或临时用法的注释。 本文档还使用最初在[RFC4366]中创建的TLS ExtensionType Values注册表。 IANA已更新它以参考此文档。 对注册表的更改如下：
 Rescorla标准跟踪[页106] 
 
 RFC 8446 TLS 2018年8月

- IANA已将注册政策更新如下： 

第一个字节在0-254（十进制）范围内的值通过Specification Required [RFC8126]分配。 第一个字节255（十进制）的值保留给专用[RFC8126] 。 

- IANA已更新此注册表，以包含“key_share”，“pre_shared_key”，“psk_key_exchange_modes”，“early_data”，“cookie”，“supported_versions”，“certificate_authorities”，“oid_filters”，“post_handshake_auth”和“signature_algorithms_cert”扩展名使用本文档中定义的值和“推荐”值“Y”。 

- IANA已更新此注册表以包含“TLS 1.3”列，其中列出了可能出现扩展名的邮件。 此列最初是从4.2节中的表中填充的，其中未列出的任何扩展名都标记为“ - ”，表示它未被TLS 1.3使用。 

本文档更新了最初在[RFC6091]中创建并在[RFC8447]中更新的TLS证书类型注册表中的条目。 IANA更新了值1的条目，使其名称为“OpenPGP_RESERVED”，“推荐”值为“N”，注释“在1.3之前的TLS版本中使用”。 

本文档更新最初在[RFC6961]中创建的TLS证书状态类型注册表中的条目 。 IANA更新了值2的条目，使其名称为“ocsp_multi_RESERVED”，并注释“在1.3之前的TLS版本中使用”。 

本文档更新了TLS支持组注册表中的两个条目（由[RFC4492]以不同名称创建;现在由[RFC8422]维护）并由[RFC7919]和[RFC8447]更新 。 值29和30（x25519和x448）的条目已更新，也可参考本文档。 此外，本文档定义了由IANA维护的两个新注册管理机构：
 Rescorla Standards Track [第107页] 
 
 RFC 8446 TLS 2018年8月

- TLS SignatureScheme注册表：具有0-253（十进制）范围内第一个字节的值通过Specification Required [RFC8126]分配。 第一个字节254或255（十进制）的值保留给专用[RFC8126] 。 具有0-6范围内的第一个字节或当前未分配的0-3范围内的第二个字节的值保留用于向后兼容。 此注册表具有“推荐”列。 注册表最初填充了第4.2.3节中描述的值。 以下值标记为“推荐”：ecdsa_secp256r1_sha256，ecdsa_secp384r1_sha384，rsa_pss_rsae_sha256，rsa_pss_rsae_sha384，rsa_pss_rsae_sha512，rsa_pss_pss_sha256，rsa_pss_pss_sha384，rsa_pss_pss_sha512和ed25519。 除非明确请求，否则“推荐”列的值为“N”，并且添加“推荐”值为“Y”的值需要标准操作[RFC8126] 。 IESG批准需要Y-> N转换。 

- TLS PskKeyExchangeMode注册表：0-253（十进制）范围内的值通过Specification Required [RFC8126]分配。 值254和255（十进制）保留给专用[RFC8126] 。 此注册表具有“推荐”列。 注册表最初填充了psk_ke（0）和psk_dhe_ke（1）。 两者都标记为“推荐”。 除非明确请求，否则“推荐”列的值为“N”，并且添加“推荐”值为“Y”的值需要标准操作[RFC8126] 。 IESG批准需要Y-> N转换。
 Rescorla标准轨道[第108页] 
 
 RFC 8446 TLS 2018年8月

12 。 参考 
 12.1 。  规范性参考文献

[ DH76 ] Diffie，W。和M. Hellman，“新的方向 
“密码学”，IEEE信息论交易，第22卷第6期，第644-654页，DOI 10.1109 / TIT.1976.1055638，1976年11月。 

[ ECDSA ]美国国家标准协会，“公钥 
金融服务业的密码学：椭圆曲线数字签名算法（ECDSA）“，ANSI ANS X9.62-2005，2005年11月。

[ GCM ] Dworkin，M。，“块密码模式的推荐 
操作：伽罗瓦/计数器模式（GCM）和GMAC“，NIST特刊800-38D，DOI 10.6028 / NIST.SP.800-38D，2007年11月。 

[ RFC2104 ] Krawczyk，H.，Bellare，M。和R. Canetti，“HMAC：Keyed- 
Hashing for Message Authentication“， RFC 2104 ，DOI 10.17487 / RFC2104，1997年2月，< https://www.rfc-editor.org/info/rfc2104 >。 

[ RFC2119 ] Bradner，S。，“用于RFC指示的关键词 
要求等级“， BCP 14 ， RFC 2119 ，DOI 10.17487 / RFC2119，1997年3月，< https://www.rfc-editor.org/info/rfc2119 >。 

[ RFC5116 ] McGrew，D。，“用于认证的接口和算法 
加密“， RFC 5116 ，DOI 10.17487 / RFC5116，2008年1月，< https://www.rfc-editor.org/info/rfc5116 >。 

[ RFC5280 ] Cooper，D.，Santesson，S.，Farrell，S.，Boeyen，S。， 
Housley，R。和W. Polk，“Internet X.509公钥基础结构证书和证书撤销列表（CRL）配置文件”， RFC 5280 ，DOI 10.17487 / RFC5280，2008年5月，< https：//www.rfc-editor .org / info / rfc5280 >。 

[ RFC5705 ] Rescorla，E。，“Keying Material Exporters for Transport 
Layer Security（TLS）“， RFC 5705 ，DOI 10.17487 / RFC5705，2010年3月，< https://www.rfc-editor.org/info/rfc5705 >。 

[ RFC5756 ] Turner，S.，Brown，D.，Yiu，K.，Housley，R。和T. Polk， 
“RSAES-OAEP和RSASSA-PSS算法参数的更新”， RFC 5756 ，DOI 10.17487 / RFC5756，2010年1月，< https://www.rfc-editor.org/info/rfc5756 >。 



 Rescorla Standards Track [第109页] 
 
 RFC 8446 TLS 2018年8月


[ RFC5869 ] Krawczyk，H。和P. Eronen，“基于HMAC的Extract-and-Expand 
密钥衍生函数（HKDF）“， RFC 5869 ，DOI 10.17487 / RFC5869，2010年5月，< https://www.rfc-editor.org/info/rfc5869 >。 

[ RFC6066 ] Eastlake 3rd，D。，“传输层安全性（TLS） 
扩展：扩展定义“， RFC 6066 ，DOI 10.17487 / RFC6066，2011年1月，< https://www.rfc-editor.org/info/rfc6066 >。 

[ RFC6655 ] McGrew，D。和D. Bailey，“AES-CCM Cipher Suites for 
传输层安全性（TLS）“， RFC 6655 ，DOI 10.17487 / RFC6655，2012年7月，< https://www.rfc-editor.org/info/rfc6655 >。 

[ RFC6960 ] Santesson，S.，Myers，M.，Ankney，R.，Malpani，A.， 
Galperin，S。和C. Adams，“X.509互联网公钥基础设施在线证书状态协议 - OCSP”， RFC 6960 ，DOI 10.17487 / RFC6960，2013年6月，< https://www.rfc-editor.org/ info / rfc6960 >。 

[ RFC6961 ] Pettersen，Y。，“传输层安全性（TLS） 
多证书状态请求扩展“， RFC 6961 ，DOI 10.17487 / RFC6961，2013年6月，< https://www.rfc-editor.org/info/rfc6961 >。 

[ RFC6962 ] Laurie，B.，Langley，A。和E. Kasper，“证书 
透明度“， RFC 6962 ，DOI 10.17487 / RFC6962，2013年6月，< https://www.rfc-editor.org/info/rfc6962 >。 

[ RFC6979 ] Pornin，T。，“数字签名的确定性用法” 
算法（DSA）和椭圆曲线数字签名算法（ECDSA）“， RFC 6979 ，DOI 10.17487 / RFC6979，2013年8月，< https://www.rfc-editor.org/info/rfc6979 >。 

[ RFC7301 ] Friedl，S.，Popov，A.，Langley，A。和E. Stephan， 
“传输层安全性（TLS）应用层协议协商扩展”， RFC 7301 ，DOI 10.17487 / RFC7301，2014年7月，< https://www.rfc-editor.org/info/rfc7301 >。 

[ RFC7507 ] Moeller，B。和A. Langley，“TLS后备信号密码 
用于防止协议降级攻击的套件值（SCSV）“， RFC 7507 ，DOI 10.17487 / RFC7507，2015年4月，< https://www.rfc-editor.org/info/rfc7507 >。 

[ RFC7748 ] Langley，A.，Hamburg，M。和S. Turner，“Elliptic Curves 
for Security“， RFC 7748 ，DOI 10.17487 / RFC7748，2016年1月，< https://www.rfc-editor.org/info/rfc7748 >。 


 Rescorla标准轨道[页110] 
 
 RFC 8446 TLS 2018年8月


[ RFC7919 ] Gillmor，D。，“Negotiated Finite Field Diffie-Hellman 
传输层安全性（TLS）的短暂参数“， RFC 7919 ，DOI 10.17487 / RFC7919，2016年8月，< https://www.rfc-editor.org/info/rfc7919 >。 

[ RFC8017 ] Moriarty，K.，Ed。，Kaliski，B.，Jonsson，J。和A. Rusch， 
“PKCS＃1：RSA密码规范版本2.2”， RFC 8017 ，DOI 10.17487 / RFC8017，2016年11月，< https://www.rfc-editor.org/info/rfc8017 >。 

[ RFC8032 ] Josefsson，S。和I. Liusvaara，“Edwards-Curve Digital 
签名算法（EdDSA）“， RFC 8032 ，DOI 10.17487 / RFC8032，2017年1月，< https://www.rfc-editor.org/info/rfc8032 >。 

[ RFC8126 ] Cotton，M.， Leiba ，B。和T. Narten，“指南” 
在RFC中编写IANA注意事项部分“， BCP 26 ， RFC 8126 ，DOI 10.17487 / RFC8126，2017年6月，< https://www.rfc-editor.org/info/rfc8126 >。 

[ RFC8174 ] Leiba ，B。，“大写与小写的歧义” 
RFC 2119关键词“， BCP 14 ， RFC 8174 ，DOI 10.17487 / RFC8174，2017年5月，< https://www.rfc-editor.org/info/rfc8174 >。 

[ RFC8439 ] Nir，Y。和A. Langley，“用于IETF的ChaCha20和Poly1305 
协议“， RFC 8439 ，DOI 10.17487 / RFC8439，2018年6月，< https://www.rfc-editor.org/info/rfc8439 >。 

[ SHS ] Dang，Q。，“安全哈希标准（SHS）”，国立研究所 
标准和技术报告，DOI 10.6028 / NIST.FIPS.180-4，2015年8月。 

[ X690 ] ITU-T，“信息技术 - ASN.1编码规则： 
基本编码规则（BER），规范编码规则（CER）和可分辨编码规则（DER）的规范“，ISO / IEC 8825-1：2015，2015年11月。
 Rescorla Standards Track [Page 111] 
 
 RFC 8446 TLS 2018年8月
 12.2 。  信息参考

[ AEAD-LIMITS ] 
Luykx，A。和K. Paterson，“限制在TLS中使用经过身份验证的加密”，2017年8月，< http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf >。 

[ BBFGKZ16 ] 
Bhargavan，K.，Brzuska，C.，Fournet，C.，Green，M.，Kohlweiss，M。和S. Zanella-Beguelin，“降级密钥交换协议中的弹性”，IEEE安全和隐私研讨会论文集（圣何塞），DOI 10.1109 / SP.2016.37，2016年5月。 

[ BBK17 ] Bhargavan，K.，Blanchet，B。和N. Kobeissi，“已验证 
TLS 1.3标准候选人的模型和参考实现“，IEEE安全和隐私研讨会论文集（圣何塞），DOI 10.1109 / SP.2017.26，2017年5月。 

[ BDFKPPRSZZ16 ] 
Bhargavan，K.，Delignat-Lavaud，A.，Fournet，C.，Kohlweiss，M.，Pan，J.，Protzenko，J.，Rastogi，A.，Swamy，N.，Zanella-Beguelin，S。，and J. Zinzindohoue，“实施和证明TLS 1.3记录层”，IEEE安全与隐私研讨会论文集（圣何塞），2017年5月，< https://eprint.iacr.org/2016/1178 >。 

[ Ben17a ] Benjamin，D。，“在TLS工作组前的演讲 
IETF 100“，2017年11月，< https://datatracker.ietf.org/meeting/100/materials/ slides-100-tls-sessa-tls13 / >。 

[ Ben17b ] Benjamin，D。，“来自Chrome的额外TLS 1.3结果”， 
2017年12月18日发送给TLS邮件列表的消息，< https://www.ietf.org/mail-archive/web/tls/current/ msg25168.html >。 

[ Blei98 ] Bleichenbacher，D。，“选择密文攻击 
基于RSA加密标准PKCS的协议＃1“，CRYPTO '98，1998年的会议录。 

[ BMMRT15 ] Badertscher，C.，Matt，C.，Maurer，U.，Rogaway，P。和B. 
Tackmann，“增强的安全通道和TLS 1.3记录层的目标”，ProvSec 2015，2015年9月，< https://eprint.iacr.org/2015/394 >。 




 Rescorla Standards Track [Page 112] 
 
 RFC 8446 TLS 2018年8月


[ BT16 ] Bellare，M。和B. Tackmann，“多用户安全性 
经过身份验证的加密：TLS 1.3“中的AES-GCM，2016年7月CRYPTO会议录，< https://eprint.iacr.org/2016/564 >。 

[ CCG16 ] Cohn-Gordon，K.，Cremers，C。和L. Garratt，“On 
妥协后安全“，IEEE计算机安全基础研讨会，DOI 10.1109 / CSF.2016.19，2015年7月。 

[ 检查 ] 
Checkoway，S.，Maskiewicz，J.，Garman，C.，Fried，J.，Cohney，S.，Green，M.，Heninger，N.，Weinmann，R.，Rescorla，E。和H. Shacham， “瞻博网络双EC事件的系统分析”，2016年ACM SIGSAC计算机与通信安全会议论文集 - CCS '16，DOI 10.1145 / 2976749.2978395，2016年10月。

[ CHHSV17 ] Cremers，C.，Horvat，M.，Hoyland，J.，Scott，S。和T. 
van der Merwe，“尴尬握手：修订版18中握手后模式下客户端身份验证的客户端/服务器视图可能不匹配”，消息发送至TLS邮件列表，2017年2月10日，< https://www.ietf.org/ mail-archive / web / tls / current / msg22382.html >。 

[ CHSV16 ] Cremers，C.，Horvat，M.，Scott，S。和T. van der Merwe， 
“TLS 1.3的自动分析和验证：0-RTT，恢复和延迟认证”，IEEE安全和隐私研讨会论文集（圣何塞），DOI 10.1109 / SP.2016.35，2016年5月，< https://ieeexplore.ieee .org / document / 7546518 / >。 

[ CK01 ] Canetti，R。和H. Krawczyk，“钥匙交换分析” 
协议及其用于构建安全信道的方法“，Eurocrypt 2001年会议录，DOI 10.1007 / 3-540-44987-6_28，2001年4月。 

[ CLINIC ] Miller，B.，Huang，L.，Joseph，A。和J. Tygar，“我知道 
你为什么去诊所：HTTPS流量分析的风险和实现“，隐私增强技术，第143-163页，DOI 10.1007 / 978-3-319-08506-7_8,2014。 

[ DFGS15 ] Dowling，B.，Fischlin，M.，Guenther，F。和D. Stebila， 
“TLS 1.3握手协议候选人的密码分析”，ACM CCS 2015年会议记录，2015年10月，< https://eprint.iacr.org/2015/914 >。
 Rescorla Standards Track [Page 113] 
 
 RFC 8446 TLS 2018年8月
[ DFGS16 ] Dowling，B.，Fischlin，M.，Guenther，F。和D. Stebila， 
“TLS 1.3完整和预共享密钥握手协议的加密分析”，TRON 2016，2016年2月，< https://eprint.iacr.org/2016/081 >。 

[ DOW92 ] Diffie，W.，van Oorschot，P。和M. Wiener， 
“认证和认证密钥交换”，设计，代码和密码学，DOI 10.1007 / BF00124891，1992年6月。 

[ DSS ]美国国家标准与技术研究所 
商务部，“数字签名标准（DSS）”，NIST FIPS PUB 186-4，DOI 10.6028 / NIST.FIPS.186-4，2013年7月。 

[ FG17 ] Fischlin，M。和F. Guenther，“重播对零的攻击 
往返时间：TLS 1.3握手候选人案例“，EuroS＆P 2017年会议录，2017年4月，< https://eprint.iacr.org/2017/082 >。 

[ FGSW16 ] Fischlin，M.，Guenther，F.，Schmidt，B。和B. Warinschi， 
“密钥交换中的关键确认：对TLS 1.3的正式处理及其影响”，IEEE安全与隐私研讨会论文集（圣何塞），DOI 10.1109 / SP.2016.34，2016年5月，< https://ieeexplore.ieee.org / document / 7546517 / >。 

[ FW15 ] Weimer，F。，“使用TLS完美转发RSA密钥 
保密“，2015年9月。 

[ HCJC16 ] Husak，M.，Cermak，M.，Jirsik，T。和P. Celeda，“HTTPS 
使用被动SSL / TLS指纹识别进行流量分析和客户识别“，EURASIP Journal on Information Security，Vol.2016，DOI 10.1186 / s13635-016-0030-7，2016年2月。 

[ HGFS15 ] Hlauschek，C.，Gruber，M.，Fankhauser，F。和C. Schanes， 
“PAND开放潘多拉盒子：KCI攻击TLS”，USENIX进攻技术研讨会论文集，2015年8月。 

[ IEEE1363 ] 
IEEE，“IEEE公钥加密标准规范”，IEEE标准。 1363-2000，DOI 10.1109 / IEEESTD.2000.92292。
 Rescorla标准跟踪[页114] 
 
 RFC 8446 TLS 2018年8月
[ JSS15 ] Jager，T.，Schwenk，J。和J. Somorovsky，“On the 
TCS 1.3和QUIC的安全性反对PKCS中的弱点＃1 v1.5加密“，ACM CCS 2015会议记录，DOI 10.1145 / 2810103.2813657，2015年10月，< https://www.nds.rub.de/media/nds/ veroeffentlichungen /2015/08/21/Tls13QuicAttacks.pdf >。 

[ 基准 ] 
Barker，E.，Chen，L.，Roginsky，A.，Vassilev，A。和R. Davis，“使用离散对数密码学的双智能密钥建立方案的建议书”，国家标准与技术研究所，DOI 10.6028 / NIST.SP.800-56Ar3，2018年4月。 

[ Kraw10 ] Krawczyk，H。，“Cryptographic Extraction and Key 
推导：HKDF计划“，2010年8月CRYPTO会议录，< https://eprint.iacr.org/2010/264 >。 

[ Kraw16 ] Krawczyk，H。，“单边到相互认证 
密钥交换编译器（TLS 1.3中的客户端身份验证应用程序，ACM CCS 2016会议记录，2016年10月，< https://eprint.iacr.org/2016/711 >。 

[ KW16 ] Krawczyk，H。和H. Wee，“OPTLS协议和TLS 1.3”， 
2016年3月EuroS＆P 2016会议录，< https://eprint.iacr.org/2015/978 >。 

[ LXZFH16 ] Li，X.，Xu，J.，Zhang，Z.，Feng，D。和H. Hu，“Multiple 
TLS 1.3候选人的握手安全“，IEEE安全和隐私研讨会论文集（圣何塞），DOI 10.1109 / SP.2016.36，2016年5月，< https://ieeexplore.ieee.org/document/7546519/ >。 

[ Mac17 ] MacCarthaigh，C。，“TLS1.3 0-RTT的安全评论”， 
2017年3月，< https://github.com/tlswg/tls13-spec/ issues / 1001 >。 

[ PS18 ] Patton，C。和T. Shrimpton，“部分指明 
渠道：没有省略的TLS 1.3记录层“，2018，< https://eprint.iacr.org/2018/634 >。 

[ PSK-FINISHED ] 
Scott，S.，Cremers，C.，Horvat，M。和T. van der Merwe，“修订版10：在PSK期间允许客户端身份验证时可能发生的攻击”，向TLS邮件列表发送消息，2015年10月31日，< https ：//www.ietf.org/ mail-archive / web / tls / current / msg18215.html >。 



 Rescorla Standards Track [第115页] 
   RFC 8446 TLS 2018年8月 
[ REKEY ] Abdalla，M。和M. Bellare，“增加一个人的一生 
关键：重新键入技术安全性的比较分析“，ASIACRYPT 2000，DOI 10.1007 / 3-540-44448-3_42，2000年10月。 

[ Res17a ] Rescorla，E。，“Firefox TLS 1.3的初步数据 
Middlebox实验“，发送给TLS邮件列表的消息，2017年12月5日，< https://www.ietf.org/ mail-archive / web / tls / current / msg25091.html >。 

[ Res17b ] Rescorla，E。，“更多兼容性测量结果”， 
2017年12月22日发送给TLS邮件列表的消息，< https://www.ietf.org/mail-archive/web/tls/current/ msg25179.html >。 

[ RFC3552 ] Rescorla，E。和B. Korver，“编写RFC的指南” 
安全注意事项的文本“， BCP 72 ， RFC 3552 ，DOI 10.17487 / RFC3552，2003年7月，< https://www.rfc-editor.org/info/rfc3552 >。 

[ RFC4086 ] Eastlake 3rd，D.，Schiller，J。和S. Crocker， 
“安全性的随机性要求”， BCP 106 ， RFC 4086 ，DOI 10.17487 / RFC4086，2005年6月，< https://www.rfc-editor.org/info/rfc4086 >。 

[ RFC4346 ] Dierks，T。和E. Rescorla，“传输层安全性 
（TLS）协议版本1.1“， RFC 4346 ，DOI 10.17487 / RFC4346，2006年4月，< https://www.rfc-editor.org/info/rfc4346 >。 

[ RFC4366 ] Blake-Wilson，S.，Nystrom，M.，Hopwood，D.，Mikkelsen，J.， 
和T. Wright，“传输层安全性（TLS）扩展”， RFC 4366 ，DOI 10.17487 / RFC4366，2006年4月，< https://www.rfc-editor.org/info/rfc4366 >。 

[ RFC4492 ] Blake-Wilson，S.，Bolyard，N.，Gupta，V.，Hawk，C。和B. 
Moeller，“椭圆曲线密码（ECC）传输层安全密码套件（TLS）”， RFC 4492 ，DOI 10.17487 / RFC4492，2006年5月，< https://www.rfc-editor.org/info/rfc4492 >。 

[ RFC5077 ] Salowey，J.，Zhou，H.，Eronen，P。和H. Tschofenig， 
“没有服务器端状态的传输层安全性（TLS）会话恢复”， RFC 5077 ，DOI 10.17487 / RFC5077，2008年1月，< https://www.rfc-editor.org/info/rfc5077 >。
 Rescorla Standards Track [Page 116] 
 
 RFC 8446 TLS 2018年8月
[ RFC5246 ] Dierks，T。和E. Rescorla，“传输层安全性 
（TLS）协议版本1.2“， RFC 5246 ，DOI 10.17487 / RFC5246，2008年8月，< https://www.rfc-editor.org/info/rfc5246 >。 

[ RFC5764 ] McGrew，D。和E. Rescorla，“数据报传输层 
用于建立安全实时传输协议（SRTP）密钥的安全性（DTLS）扩展“， RFC 5764 ，DOI 10.17487 / RFC5764，2010年5月，< https://www.rfc-editor.org/info/rfc5764 >。 

[ RFC5929 ] Altman，J.，Williams，N。和L. Zhu，“Channel Bindings 
for TLS“， RFC 5929 ，DOI 10.17487 / RFC5929，2010年7月，< https://www.rfc-editor.org/info/rfc5929 >。 

[ RFC6091 ] Mavrogiannopoulos，N。和D. Gillmor，“使用OpenPGP密钥 
用于传输层安全性（TLS）认证“， RFC 6091 ，DOI 10.17487 / RFC6091，2011年2月，< https://www.rfc-editor.org/info/rfc6091 >。 

[ RFC6101 ] Freier，A.，Karlton，P。和P. Kocher，“The Secure 
套接字层（SSL）协议版本3.0“， RFC 6101 ，DOI 10.17487 / RFC6101，2011年8月，< https://www.rfc-editor.org/info/rfc6101 >。 

[ RFC6176 ] Turner，S。和T. Polk，“禁止安全套接字层 
（SSL）版本2.0“， RFC 6176 ，DOI 10.17487 / RFC6176，2011年3月，< https://www.rfc-editor.org/info/rfc6176 >。 

[ RFC6347 ] Rescorla，E。和N. Modadugu，“数据报传输层 
安全版本1.2“， RFC 6347 ，DOI 10.17487 / RFC6347，2012年1月，< https://www.rfc-editor.org/info/rfc6347 >。 

[ RFC6520 ] Seggelmann ，R.，Tuexen，M。和M. Williams，“Transport 
层安全性（TLS）和数据报传输层安全性（DTLS）心跳扩展“， RFC 6520 ，DOI 10.17487 / RFC6520，2012年2月，< https://www.rfc-editor.org/info/rfc6520 >。 

[ RFC7230 ] Fielding，R.，Ed。 和J. Reschke，Ed。，“Hypertext Transfer 
协议（HTTP / 1.1）：消息语法和路由“， RFC 7230 ，DOI 10.17487 / RFC7230，2014年6月，< https://www.rfc-editor.org/info/rfc7230 >。
 Rescorla标准轨道[页117] 
 
 RFC 8446 TLS 2018年8月
[ RFC7250 ] Wouters，P.，Ed。，Tschofenig，H.，Ed。，Gilmore，J.， 
Weiler，S。和T. Kivinen，“在传输层安全性（TLS）和数据报传输层安全性（DTLS）中使用原始公钥”， RFC 7250 ，DOI 10.17487 / RFC7250，2014年6月，< https：// www。 rfc-editor.org/info/rfc7250 >。 

[ RFC7465 ] Popov，A。，“禁止RC4密码套件”， RFC 7465 ， 
DOI 10.17487 / RFC7465，2015年2月，< https://www.rfc-editor.org/info/rfc7465 >。 

[ RFC7568 ] Barnes，R.，Thomson，M.，Pironti，A。和A. Langley， 
“弃用安全套接字层版本3.0”， RFC 7568 ，DOI 10.17487 / RFC7568，2015年6月，< https://www.rfc-editor.org/info/rfc7568 >。 

[ RFC7627 ] Bhargavan，K.，Ed。，Delignat-Lavaud，A.，Pironti，A。， 
Langley，A。和M. Ray，“传输层安全性（TLS）会话哈希和扩展主密钥扩展”， RFC 7627 ，DOI 10.17487 / RFC7627，2015年9月，< https://www.rfc-editor.org/ info / rfc7627 >。 

[ RFC7685 ] Langley，A。，“传输层安全性（TLS）ClientHello 
Padding Extension“， RFC 7685 ，DOI 10.17487 / RFC7685，2015年10月，< https://www.rfc-editor.org/info/rfc7685 >。 

[ RFC7924 ] Santesson，S。和H. Tschofenig，“传输层安全性 
（TLS）缓存信息扩展“， RFC 7924 ，DOI 10.17487 / RFC7924，2016年7月，< https://www.rfc-editor.org/info/rfc7924 >。 

[ RFC8305 ] Schinazi，D。和T. Pauly，“Happy Eyeballs Version 2： 
使用并发更好的连接“， RFC 8305 ，DOI 10.17487 / RFC8305，2017年12月，< https://www.rfc-editor.org/info/rfc8305 >。 

[ RFC8422 ] Nir，Y.，Josefsson，S。和M. Pegourie-Gonnard，“Elliptic 
用于传输层安全性（TLS）版本1.2及更早版本的曲线加密（ECC）密码套件“， RFC 8422 ，DOI 10.17487 / RFC8422，2018年8月，< https://www.rfc-editor.org/info/rfc8422 >。 

[ RFC8447 ] Salowey，J。和S. Turner，“针对TLS的IANA注册管理机构更新 
和DTLS“， RFC 8447 ，DOI 10.17487 / RFC8447，2018年8月，< https://www.rfc-editor.org/info/rfc8447 >。 

[ RFC8449 ] Thomson，M。，“TLS的记录大小限制扩展”， 
RFC 8449 ，DOI 10.17487 / RFC8449，2018年8月，< https://www.rfc-editor.org/info/rfc8449 >。 


 Rescorla Standards Track [第118页] 
 
 RFC 8446 TLS 2018年8月


[ RSA ] Rivest，R.，Shamir，A。和L. Adleman，“一种方法 
获得数字签名和公钥密码系统“，ACM的通讯，第21卷第2期，第120-126页，DOI 10.1145 / 359340.359342，1978年2月。 

[ SIGMA ] Krawczyk，H。，“SIGMA：'SIGn-and-MAc'方法 
经认证的Diffie-Hellman及其在IKE协议中的使用“，CRYPTO 2003年会议论文集，DOI 10.1007 / 978-3-540-45146-4_24，2003年8月。 

[ SLOTH ] Bhargavan，K。和G. Leurent，“Transcript Collision 
攻击：在TLS，IKE和SSH中破解身份验证“，网络和分布式系统安全研讨会（NDSS 2016），DOI 10.14722 / ndss.2016.23418，2016年2月。 

[SSL2] Hickman，K。，“SSL协议”，1995年2月。 

[时间] Boneh，D。和D. Brumley，“远程计时攻击是 
实用“，USENIX安全研讨会，2003年8月。 

[ TLS13-TRACES ] 
Thomson，M。， “TLS 1.3的示例握手痕迹” ，正在进行的工作， draft-ietf-tls-tls13-vectors-06 ，2018年7月。 

[ X501 ] ITU-T，“信息技术 - 开放系统 
互连 - 目录：模型“，ITU-T X.501，2016年10月，< https://www.itu.int/rec/T-REC-X.501/en >。
 Rescorla Standards Track [第119页] 
 
 RFC 8446 TLS 2018年8月
 附录A.  国家机器

本附录提供了客户端和服务器握手的合法状态转换的摘要。 州名（在所有首都，例如，START）没有正式的含义，但是为了便于理解而提供。 仅在某些情况下采取的行动在[]中指出。 符号“K_ {send，recv} = foo”表示“将send / recv键设置为给定键”。 
 A.1 。  客户

                              开始<---- +
               发送ClientHello |  |  Recv HelloRetryRequest
           [K_send =早期数据] |  |
                                 v |
            / WAIT_SH ---- +
            |  |  Recv ServerHello
            |  |  K_recv =握手
       可以|  V
      发送|  WAIT_EE
     早期|  |  Recv EncryptedExtensions
      数据|  + -------- + -------- +
            | 使用|  | 使用证书
            |  PSK |  v
            |  |  WAIT_CERT_CR
            |  |  Recv |  |  Recv CertificateRequest
            |  | 证书|  v
            |  |  |  WAIT_CERT
            |  |  |  |  Recv证书
            |  |  VV
            |  |  WAIT_CV
            |  |  |  Recv CertificateVerify
            |  +> WAIT_FINISHED <+
            |  |  Recv完成了
            \ |  [发送EndOfEarlyData]
| K_send =握手| [发送证书[+ CertificateVerify]]可以发送| 发送完成的应用数据 - > | K_send = K_recv =此后的应用程序v 
连接的 

请注意，对于上面显示的转换，客户端可以使用clear或早期数据键发送从PostHello之后的消息派生的警报。 如果客户端需要发送此类警报，则应尽可能首先重新设置握手密钥。 




 Rescorla Standards Track [第120页] 
 
 RFC 8446 TLS 2018年8月


 A.2 。  服务器

                              开始<----- +
                Recv ClientHello |  | 发送HelloRetryRequest
                                 v |
                              RECVD_CH ---- +
                                 | 选择参数
v 
议 
| 发送ServerHello | K_send =握手| 发送EncryptedExtensions | [发送证书请求]可以发送| [发送证书+ CertificateVerify]应用数据| 发送完成后 - > | K_send =这里的应用程序+ -------- + -------- +
              没有0-RTT |  |  0-RTT
                        |  |
    K_recv =握手|  |  K_recv =早期数据
[跳过解密错误] | + ------> WAIT_EOED - +
                        |  |  Recv |  |  Recv EndOfEarlyData
                        |  | 早期数据|  |  K_recv =握手
                        |  + ------------ + |
                        |  |
                        +> WAIT_FLIGHT2 <-------- +
                                 |
                        + -------- + -------- +
               没有auth |  | 客户端认证
                        |  |
                        |  v
                        |  WAIT_CERT
                        |  Recv |  |  Recv证书
                        | 空|  v
                        | 证书|  WAIT_CV
                        |  |  | 的recv
                        |  v |  CertificateVerify
                        +  - > WAIT_FINISHED <--- +
                                 |  Recv完成了
| K_recv =申请v 
连接的
 Rescorla标准跟踪[页121] 
 
 RFC 8446 TLS 2018年8月
 附录B.  协议数据结构和常量值

本附录提供了规范协议类型和常量定义。 列为“_RESERVED”的值在以前版本的TLS中使用，并在此处列出是为了完整性。 TLS 1.3实现绝不能发送它们，但可能从较旧的TLS实现接收它们。 
 B.1 。  记录层

枚举{ 
invalid（0），change_cipher_spec（20），alert（21），handshake（22），application_data（23），heartbeat（24），/ * RFC 6520 * /（255）} ContentType; 

struct {ContentType type; ProtocolVersion legacy_record_version; uint16长度; 不透明片段[TLSPlaintext.length]; TLSPlaintext; 

struct {opaque content [TLSPlaintext.length]; ContentType类型; uint8 zeros [length_of_padding]; } TLSInnerPlaintext; 

struct {ContentType opaque_type = application_data; / * 23 * / ProtocolVersion legacy_record_version = 0x0303; / * TLS v1.2 * / uint16 length; opaque encrypted_record [TLSCiphertext.length]; 
} TLSCiphertext;
 Rescorla Standards Track [第122页] 
 
 RFC 8446 TLS 2018年8月
 B.2 。  警报信息

enum {warning（1），fatal（2），（255）} AlertLevel; 

枚举{close_notify（0），unexpected_message（10），bad_record_mac（20），decryption_failed_RESERVED（21），record_overflow（22），decompression_failure_RESERVED（30），handshake_failure（40），no_certificate_RESERVED（41），bad_certificate（42），unsupported_certificate（43） ），certificate_revoked（44），certificate_expired（45），certificate_unknown（46），illegal_parameter（47），unknown_ca（48），access_denied（49），decode_error（50），decrypt_error（51），export_restriction_RESERVED（60），protocol_version（70） ），insufficient_security（71），internal_error（80），impro_fallback（86），user_canceled（90），no_renegotiation_RESERVED（100），missing_extension（109），unsupported_extension（110），certificate_unobtainable_RESERVED（111），unrecognized_name（112），bad_certificate_status_response（113） ），bad_certificate_hash_value_RESERVED（114），unknown_psk_identity（115），certificate_required（116），no_application_protocol（120），（255）} AlertDescription;

struct {AlertLevel level; AlertDescription描述; 
警报; 




 Rescorla Standards Track [Page 123] 
 
 RFC 8446 TLS 2018年8月


 B.3 。  握手协议

枚举{ 
hello_request_RESERVED（0），client_hello（1），server_hello（2），hello_verify_request_RESERVED（3），new_session_ticket（4），end_of_early_data（5），hello_retry_request_RESERVED（6），encrypted_extensions（8），certificate（11），server_key_exchange_RESERVED（12）， certificate_request（13），server_hello_done_RESERVED（14），certificate_verify（15），client_key_exchange_RESERVED（16），finished（20），certificate_url_RESERVED（21），certificate_status_RESERVED（22），supplemental_data_RESERVED（23），key_update（24），message_hash（254）， （255）} HandshakeType; 

struct {HandshakeType msg_type; / *握手类型* / uint24长度; 消息中的/ *字节* /
           select（Handshake.msg_type）{
               case client_hello：ClientHello;
               case server_hello：ServerHello;
               case end_of_early_data：EndOfEarlyData;
case encrypted_extensions：EncryptedExtensions; case certificate_request：CertificateRequest; 案件证明：证书; case certificate_verify：CertificateVerify; 案件结束：完成; case new_session_ticket：NewSessionTicket; case key_update：KeyUpdate; 
}; 
握手;
 Rescorla Standards Track [第124页] 
 
 RFC 8446 TLS 2018年8月
 B.3.1 。  密钥交换消息

uint16 ProtocolVersion; 不透明随机[32]; 

uint8 CipherSuite [2]; / *加密套件选择器* / 

struct {ProtocolVersion legacy_version = 0x0303; / * TLS v1.2 * /随机随机; opaque legacy_session_id <0..32>; CipherSuite cipher_suites <2..2 ^ 16-2>; opaque legacy_compression_methods <1..2 ^ 8-1>; 扩展名扩展名<8..2 ^ 16-1>; ClientHello; 

struct {ProtocolVersion legacy_version = 0x0303; / * TLS v1.2 * /随机随机; opaque legacy_session_id_echo <0..32>; CipherSuite cipher_suite; uint8 legacy_compression_method = 0; 扩展名扩展名<6..2 ^ 16-1>; } ServerHello; struct {ExtensionType extension_type; opaque extension_data <0..2 ^ 16-1>; } 延期;
 Rescorla标准轨道[第125页] 
 
 RFC 8446 TLS 2018年8月

枚举{server_name（0），/ * RFC 6066 * / max_fragment_length（1），/ * RFC 6066 * / status_request（5），/ * RFC 6066 * / supported_groups（10），/ * RFC 8422,7919 * / signature_algorithms（ 13），/ * RFC 8446 * / use_srtp（14），/ * RFC 5764 * / heartbeat（15），/ * RFC 6520 * / application_layer_protocol_negotiation（16），/ * RFC 7301 * / signed_certificate_timestamp（18），/ * RFC 6962 * / client_certificate_type（19），/ * RFC 7250 * / server_certificate_type（20），/ * RFC 7250 * / padding（21），/ * RFC 7685 * / RESERVED（40），/ *已使用但从不 
分配* / 
pre_shared_key（41），/ * RFC 8446 * / early_data（42），/ * RFC 8446 * / supported_versions（43），/ * RFC 8446 * / cookie（44），/ * RFC 8446 * / psk_key_exchange_modes（45），/ * RFC 8446 * / RESERVED（46），/ *已使用但从未使用过 
分配* / 
certificate_authorities（47），/ * RFC 8446 * / oid_filters（48），/ * RFC 8446 * / post_handshake_auth（49），/ * RFC 8446 * / signature_algorithms_cert（50），/ * RFC 8446 * / key_share（51），/ * RFC 8446 * /（65535）} ExtensionType; 

struct {NamedGroup group; opaque key_exchange <1..2 ^ 16-1>; } KeyShareEntry; 

struct { 
KeyShareEntry client_shares <0..2 ^ 16-1>; 
KeyShareClientHello; 

struct { 
NamedGroup selected_group; 
} KeyShareHelloRetryRequest; struct { 



 Rescorla标准轨道[页126] 
 
 RFC 8446 TLS 2018年8月


KeyShareEntry server_share; 
KeyShareServerHello; 

struct {uint8 legacy_form = 4; 不透明的X [coordinate_length]; 不透明的Y [coordinate_length]; } UncompressedPointRepresentation; 

enum {psk_ke（0），psk_dhe_ke（1），（255）} PskKeyExchangeMode; 

struct { 
PskKeyExchangeMode ke_modes <1..255>; 
} PskKeyExchangeModes; 

struct {}空; 

struct { 
select（Handshake.msg_type）{ 
case new_session_ticket：uint32 max_early_data_size; case client_hello：空; case encrypted_extensions：空; 
}; 
} EarlyDataIndication; 

struct {opaque identity <1..2 ^ 16-1>; uint32 obfuscated_ticket_age; PskIdentity; 

opaque PskBinderEntry <32..255>; 

struct {PskIdentity identities <7..2 ^ 16-1>; PskBinderEntry粘合剂<33..2 ^ 16-1>; } OfferedPsks; 

struct { 
select（Handshake.msg_type）{ 
case client_hello：OfferedPsks; case server_hello：uint16 selected_identity; 
}; 
} PreSharedKeyExtension;
 Rescorla标准跟踪[第127页] 
 
 RFC 8446 TLS 2018年8月
 B.3.1.1 。  版本扩展

struct { 
select（Handshake.msg_type）{ 
case client_hello： 
ProtocolVersion版本<2..254>; 

case server_hello：/ *和HelloRetryRequest * / 
ProtocolVersion selected_version; 
}; 
} SupportedVersions; 
 B.3.1.2 。  Cookie扩展

struct { 
opaque cookie <1..2 ^ 16-1>; 
} 曲奇饼;
 Rescorla Standards Track [第128页] 
 
 RFC 8446 TLS 2018年8月
 B.3.1.3 。  签名算法扩展

枚举{ 
/ * RSASSA-PKCS1-v1_5算法* / rsa_pkcs1_sha256（0x0401），rsa_pkcs1_sha384（0x0501），rsa_pkcs1_sha512（0x0601）， 

/ * ECDSA算法* / ecdsa_secp256r1_sha256（0x0403），ecdsa_secp384r1_sha384（0x0503），ecdsa_secp521r1_sha512（0x0603）， 

/ * RSASSA-PSS算法，公钥OID rsaEncryption * / rsa_pss_rsae_sha256（0x0804），rsa_pss_rsae_sha384（0x0805），rsa_pss_rsae_sha512（0x0806）， 

/ * EdDSA算法* / ed25519（0x0807），ed448（0x0808）， 

/ * RSASSA-PSS算法，公钥OID RSASSA-PSS * / rsa_pss_pss_sha256（0x0809），rsa_pss_pss_sha384（0x080a），rsa_pss_pss_sha512（0x080b）， 

/ *传统算法* / rsa_pkcs1_sha1（0x0201），ecdsa_sha1（0x0203）， 

/ *保留代码点* / obsolete_RESERVED（0x0000..0x0200），dsa_sha1_RESERVED（0x0202），obsolete_RESERVED（0x0204..0x0400），dsa_sha256_RESERVED（0x0402），obsolete_RESERVED（0x0404..0x0500），dsa_sha384_RESERVED（0x0502），obsolete_RESERVED（0x0504。 .0x0600），dsa_sha512_RESERVED（0x0602），obsolete_RESERVED（0x0604..0x06FF），private_use（0xFE00..0xFFFF），（0xFFFF）} SignatureScheme; 

struct { 
SignatureScheme supported_signature_algorithms <2..2 ^ 16-2>; 
} SignatureSchemeList; 


 Rescorla Standards Track [第129页] 
 
 RFC 8446 TLS 2018年8月


 B.3.1.4 。  支持的组扩展

枚举{ 
unallocated_RESERVED（0×0000）， 

/ *椭圆曲线组（ECDHE）* / obsolete_RESERVED（0x0001..0x0016），secp256r1（0x0017），secp384r1（0x0018），secp521r1（0x0019），obsolete_RESERVED（0x001A..0x001C），x25519（0x001D），x448（0x001E） ， 

/ *有限域组（DHE）* / ffdhe2048（0x0100），ffdhe3072（0x0101），ffdhe4096（0x0102），ffdhe6144（0x0103），ffdhe8192（0x0104）， 

/ *保留代码点* / ffdhe_private_use（0x01FC..0x01FF），ecdhe_private_use（0xFE00..0xFEFF），obsolete_RESERVED（0xFF01..0xFF02），（0xFFFF）} NamedGroup; 

struct { 
NamedGroup named_group_list <2..2 ^ 16-1>; 
NamedGroupList; 

“obsolete_RESERVED”范围内的值在以前版本的TLS中使用，不得由TLS 1.3实现提供或协商。 过时的曲线具有各种已知/理论上的弱点或者使用非常少，在某些情况下仅由于无意的服务器配置问题。 它们不再被认为适合一般用途，应该被认为可能不安全。 此处指定的曲线集足以与所有当前部署和正确配置的TLS实现进行互操作。
 Rescorla Standards Track [第130页] 
 
 RFC 8446 TLS 2018年8月
 B.3.2 。  服务器参数消息

opaque DistinguishedName <1..2 ^ 16-1>; 

struct { 
DistinguishedName权限<3..2 ^ 16-1>; 
} CertificateAuthoritiesExtension; 

struct {opaque certificate_extension_oid <1..2 ^ 8-1>; opaque certificate_extension_values <0..2 ^ 16-1>; } OIDFilter; 

struct { 
OIDFilter过滤器<0..2 ^ 16-1>; 
} OIDFilterExtension; 

struct {} PostHandshakeAuth; 

struct { 
扩展扩展名<0..2 ^ 16-1>; 
加密的扩展; 

struct {opaque certificate_request_context <0..2 ^ 8-1>; 扩展名扩展名<2..2 ^ 16-1>; 
} CertificateRequest;
 Rescorla Standards Track [Page 131] 
 
 RFC 8446 TLS 2018年8月
 B.3.3 。  验证消息

枚举{ 
X509（0），OpenPGP_RESERVED（1），RawPublicKey（2），（255）} CertificateType; 

struct { 
select（certificate_type）{ 
case RawPublicKey： 
/ *来自RFC 7250 ASN.1_subjectPublicKeyInfo * / opaque ASN1_subjectPublicKeyInfo <1..2 ^ 24-1>; 

案例X509： 
opaque cert_data <1..2 ^ 24-1>; 
}; 扩展扩展名<0..2 ^ 16-1>; } CertificateEntry; 

struct {opaque certificate_request_context <0..2 ^ 8-1>; CertificateEntry certificate_list <0..2 ^ 24-1>; } 证书; 

struct {SignatureScheme算法; 不透明签名<0..2 ^ 16-1>; } CertificateVerify; 

struct { 
opaque verify_data [Hash.length]; 
完成了; 
 B.3.4 。  机票设立

struct { 
uint32 ticket_lifetime; uint32 ticket_age_add; opaque ticket_nonce <0..255>; opaque ticket <1..2 ^ 16-1>; 扩展扩展名<0..2 ^ 16-2>; 
} NewSessionTicket;
 Rescorla Standards Track [第132页] 
 
 RFC 8446 TLS 2018年8月
 B.3.5 。  更新密钥

struct {} EndOfEarlyData; 

枚举{ 
update_not_requested（0），update_requested（1），（255） 
} KeyUpdateRequest; 

struct { 
KeyUpdateRequest request_update; 
} KeyUpdate; 
 B.4 。  密码套房

对称密码套件定义了与HKDF一起使用的AEAD算法和散列算法对。 密码套件名称遵循命名约定： 

CipherSuite TLS_AEAD_HASH = VALUE; 
       + ----------- + ------------------------------------- ----------- +
       | 组件| 内容|
       + ----------- + ------------------------------------- ----------- +
       |  TLS | 字符串“TLS”|
       |  |  |
       |  AEAD | 用于记录保护的AEAD算法|
       |  |  |
       | 哈希| 与HKDF一起使用的哈希算法
       |  |  |
       | 价值| 为此密码套件分配的双字节ID
       + ----------- + ------------------------------------- ----------- +

此规范定义了以下用于TLS 1.3的密码套件。 
               + ------------------------------ + ------------- +
               | 说明| 价值|
               + ------------------------------ + ------------- +
               |  TLS_AES_128_GCM_SHA256 |  {0x13,0x01} |
               |  |  |
               |  TLS_AES_256_GCM_SHA384 |  {0x13,0x02} |
               |  |  |
               |  TLS_CHACHA20_POLY1305_SHA256 |  {0x13,0x03} |
               |  |  |
               |  TLS_AES_128_CCM_SHA256 |  {0x13,0x04} |
               |  |  |
               |  TLS_AES_128_CCM_8_SHA256 |  {0x13,0x05} |
               + ------------------------------ + ------------- +



 Rescorla Standards Track [第133页] 
 
 RFC 8446 TLS 2018年8月


相应的AEAD算法AEAD_AES_128_GCM，AEAD_AES_256_GCM和AEAD_AES_128_CCM在[RFC5116]中定义。 AEAD_CHACHA20_POLY1305在[RFC8439]中定义。 AEAD_AES_128_CCM_8在[RFC6655]中定义。 相应的哈希算法在[SHS]中定义。 

尽管TLS 1.3使用与先前版本的TLS相同的密码套件空间，但TLS 1.3密码套件的定义不同，仅指定对称密码，不能用于TLS 1.2。 同样，TLS 1.2及更低版本的密码套件不能与TLS 1.3一起使用。 

新的密码套件值由IANA分配，如第11节所述。 
 附录C.  实施说明

TLS协议无法阻止许多常见的安全错误。 本附录提供了一些帮助实施者的建议。 [TLS13-TRACES]为TLS 1.3握手提供测试向量。 
 C.1 。  随机数生成和播种

TLS需要加密安全的伪随机数生成器（CSPRNG）。 在大多数情况下，操作系统提供适当的工具，例如/ dev / urandom，应该在没有其他（例如性能）问题的情况下使用。 建议使用现有的CSPRNG实现，而不是制作新的CSPRNG实现。 许多适当的加密库已经在有利的许可条款下可用。 如果这些证明不令人满意， [RFC4086]提供了随机值生成的指导。 

TLS在公共协议字段中使用随机值（1），例如ClientHello和ServerHello中的公共随机值，以及（2）生成密钥材料。 通过正常运行的CSPRNG，这不会带来安全问题，因为从输出中确定CSPRNG状态是不可行的。 但是，如果CSPRNG损坏，攻击者可能会使用公共输出来确定CSPRNG内部状态，从而预测密钥材料，如[CHECKOWAY]中所述 。 通过使用单独的CSPRNG生成公共和私有值，实现可以提供针对此类攻击的额外安全性。
 Rescorla Standards Track [第134页] 
 
 RFC 8446 TLS 2018年8月
 C.2 。  证书和身份验证

实现负责验证证书的完整性，并且通常应支持证书撤销消息。 如果没有来自应用程序配置文件的特定指示，则应始终验证证书以确保受信任的证书颁发机构（CA）正确签名。 应非常谨慎地选择和添加信任锚。 用户应该能够查看有关证书和信任锚的信息。 应用程序还应该强制执行最小和最大密钥大小。 例如，包含弱于2048位RSA或224位ECDSA的密钥或签名的证书路径不适用于安全应用程序。 
 C.3 。  实施陷阱

实施经验表明，早期TLS规范的某些部分不易理解，并且是互操作性和安全性问题的根源。 本文件中已阐明了其中许多方面，但本附录包含了一些需要实施者特别关注的最重要事项的简短列表。 

TLS协议问题： 

- 您是否正确处理了碎片化为多个TLS记录的握手消息（参见第5.1节 ）？ 你是否正确处理像ClientHello这样被分成几个小片段的角落案例？ 您是否将超过最大片段大小的握手消息分段？ 特别是，Certificate和CertificateRequest握手消息可能足够大，需要分段。 

- 您是否忽略所有未加密的TLS记录中的TLS记录层版本号（参见附录D ）？ 

- 您是否确保从支持TLS 1.3或更高版本的所有可能配置中完全删除对SSL，RC4，EXPORT密码和MD5（通过“signature_algorithms”扩展）的所有支持，并且尝试使用这些过时功能的尝试失败（见附录D ）？ 

- 您是否正确处理ClientHellos中的TLS扩展，包括未知扩展？
 Rescorla标准轨道[第135页] 
 
 RFC 8446 TLS 2018年8月
- 当服务器请求了客户端证书但没有合适的证书可用时，您是否正确发送了一个空的证书消息，而不是省略整个消息（参见第4.4.2节 ）？ 

- 当处理由AEAD-Decrypt生成的明文片段并从末尾扫描ContentType时，如果对等体发送了全部为零的格式错误的明文，您是否会避免扫描明文的开头？ 

- 您是否正确忽略了无法识别的密码套件（ 第4.1.2节 ），hello扩展（ 第4.2节 ），命名组（ 第4.2.7节 ），密钥共享（ 第4.2.8节 ），支持的版本（ 第4.2.1节 ），以及ClientHello中的签名算法（ 第4.2.3节 ）？ 

- 作为服务器，您是否向支持兼容（EC）DHE组但不在“key_share”扩展名中预测它的客户端发送HelloRetryRequest？ 作为客户端，您是否正确地从服务器处理HelloRetryRequest？ 

加密细节： 

- 您使用什么对策来防止定时攻击[时间] ？ 

- 使用Diffie-Hellman密钥交换时，是否正确保留了协商密钥中的前导零字节（参见第7.4.1节 ）？ 

- 您的TLS客户端是否检查服务器发送的Diffie-Hellman参数是否可接受（参见第4.2.8.1节 ）？ 

- 在生成Diffie-Hellman私有值，ECDSA“k”参数和其他安全关键值时，您是否使用强大且最重要的正确种子随机数生成器（参见附录C.1 ）？ 建议实现实现[RFC6979]中规定的“确定性ECDSA”。 

- 您是否将Diffie-Hellman公钥值和共享密钥归零到组大小（参见第4.2.8.1 节和第7.4.1节 ）？

- 您是否在制作签名后验证签名，以防止RSA-CRT密钥泄漏[FW15] ？
 Rescorla标准轨道[第136页] 
 
 RFC 8446 TLS 2018年8月
 C.4 。  客户跟踪预防

客户端不应该为多个连接重用票证。 重复使用票证允许被动观察者关联不同的连接。 发行票证的服务器应该至少提供与客户端可能使用的连接数量一样多的票证; 例如，使用HTTP / 1.1 [RFC7230]的Web浏览器可能会打开与服务器的六个连接。 服务器应该每次连接都发出新票证。 这可确保客户端始终能够在创建新连接时使用新票证。 
 C.5 。  未经身份验证的操作

早期版本的TLS提供了基于匿名Diffie-Hellman的显式未经验证的密码套件。 这些模式已在TLS 1.3中弃用。 但是，仍然可以通过多种方法协商不提供可验证服务器身份验证的参数，包括： 

- 原始公钥[RFC7250] 。 

- 使用证书中包含的公钥，但不验证证书链或其任何内容。 

单独使用这两种技术都容易受到中间人攻击，因此对于一般用途是不安全的。 但是，也可以通过服务器公钥的带外验证，首次使用时的信任或通道绑定等机制将这种连接绑定到外部认证机制（尽管[RFC5929]中描述了通道绑定）没有为TLS 1.3）定义。 如果没有使用这种机制，那么连接就没有针对主动中间人攻击的保护; 应用程序不得以缺少显式配置或特定应用程序配置文件的方式使用TLS。
 Rescorla Standards Track [第137页] 
 
 RFC 8446 TLS 2018年8月
 附录D.  向后兼容性

TLS协议为端点之间的版本协商提供了内置机制，可能支持不同版本的TLS。 

TLS 1.x和SSL 3.0使用兼容的ClientHello消息。 只要ClientHello格式保持兼容并且客户端和服务器都支持至少一个协议版本，服务器也可以处理尝试使用未来版本TLS的客户端。 

TLS的早期版本使用记录层版本号（TLSPlaintext.legacy_record_version和TLSCiphertext.legacy_record_version）用于各种目的。 从TLS 1.3开始，不推荐使用此字段。 所有实现都必须忽略TLSPlaintext.legacy_record_version的值。 TLSCiphertext.legacy_record_version的值包含在去保护的附加数据中，但可以忽略或者可以验证以匹配固定的常量值。 仅使用握手版本（ClientHello.legacy_version和ServerHello.legacy_version，以及ClientHello，HelloRetryRequest和ServerHello“supported_versions”扩展）执行版本协商。 为了最大限度地提高与旧端点的互操作性，协商使用TLS 1.0-1.2的实现应该将记录层版本号设置为ServerHello的协商版本以及之后的所有记录。 

为了最大限度地兼容以前的非标准行为和错误配置的部署，所有实现都应该支持基于本文档中的期望验证认证路径，即使在处理先前的TLS版本的握手时也是如此（参见第4.4.2.2节 ）。 

TLS 1.2和之前版本支持“扩展主密钥” [RFC7627]扩展，它将握手记录的大部分内容消化为主密钥。 因为TLS 1.3总是在转录本中哈希到服务器完成，所以支持TLS 1.3和早期版本的实现应该指示在使用TLS 1.3时在其API中使用扩展主密钥扩展。
 Rescorla标准跟踪[第138页] 
 
 RFC 8446 TLS 2018年8月
 D.1 。  与旧服务器协商

希望与不支持TLS 1.3的服务器协商的TLS 1.3客户端将在ClientHello.legacy_version中发送包含0x0303（TLS 1.2）的正常TLS 1.3 ClientHello，但在“supported_versions”扩展中使用正确的版本。 如果服务器不支持TLS 1.3，它将使用包含旧版本号的ServerHello进行响应。 如果客户同意使用此版本，则协商将根据协商协议进行。 使用故障单进行恢复的客户端应该使用先前协商的版本启动连接。 

请注意，0-RTT数据与旧服务器不兼容，并且在不知道服务器支持TLS 1.3的情况下不应发送。 见附录D.3 。 

如果客户端不支持服务器选择的版本（或者不可接受），则客户端务必使用“protocol_version”警报中止握手。 

已知一些传统服务器实现不能正确实现TLS规范，并且可能在遇到TLS扩展或他们不知道的版本时中止连接。 与错误服务器的互操作性是一个超出本文档范围的复杂主题。 可能需要多次连接尝试才能协商向后兼容的连接; 但是，这种做法很容易受到降级攻击，并且不推荐。 
 D.2 。  与老客户谈判

TLS服务器还可以接收ClientHello，指示版本号小于其支持的最高版本。 如果存在“supported_versions”扩展，则服务器必须使用该扩展进行协商，如第4.2.1节中所述。 如果“supported_versions”扩展名不存在，服务器必须协商ClientHello.legacy_version和TLS 1.2的最小值。 例如，如果服务器支持TLS 1.0,1.1和1.2，并且legacy_version是TLS 1.0，则服务器将继续使用TLS 1.0 ServerHello。 如果“supported_versions”扩展名不存在且服务器仅支持大于ClientHello.legacy_version的版本，则服务器必须使用“protocol_version”警报中止握手。

请注意，早期版本的TLS并未在所有情况下明确指定记录层版本号值（TLSPlaintext.legacy_record_version）。 服务器将在此字段中接收各种TLS 1.x版本，但必须始终忽略其值。 



 Rescorla Standards Track [第139页] 
 
 RFC 8446 TLS 2018年8月


 D.3 。  0-RTT向后兼容性

0-RTT数据与旧服务器不兼容。 较旧的服务器将使用较旧的ServerHello响应ClientHello，但它不会正确跳过0-RTT数据，并且无法完成握手。 当客户端尝试使用0-RTT时，这可能会导致问题，尤其是针对多服务器部署。 例如，部署可以逐步部署TLS 1.3，其中一些服务器实现TLS 1.3，一些服务器实现TLS 1.2，或者TLS 1.3部署可以降级为TLS 1.2。 

尝试发送0-RTT数据的客户端如果收到TLS 1.2或更早版本的ServerHello，则必须使连接失败。 然后，它可以在禁用0-RTT的情况下重试连接。 为了避免降级攻击，客户端不应该禁用TLS 1.3，只能禁用0-RTT。 

为避免此错误情况，多服务器部署应确保在启用0-RTT之前，在没有0-RTT的情况下统一且稳定地部署TLS 1.3。 
 D.4 。  Middlebox兼容模式

现场测量[Ben17a] [Ben17b] [Res17a] [Res17b]发现，当TLS客户端/服务器对协商TLS 1.3时，大量中间件行为不端。 通过使TLS 1.3握手看起来更像是TLS 1.2握手，实现可以增加通过这些中间件建立连接的机会： 

- 客户端始终在ClientHello中提供非空的会话ID，如第4.1.2节的legacy_session_id部分所述。 

- 如果不提​​供早期数据，客户端会在第二次飞行之前立即发送虚拟change_cipher_spec记录（参见第5节第 3段）。 这可能在其第二个ClientHello之前或在其加密的握手飞行之前。 如果提供早期数据，则记录会立即放在第一个ClientHello之后。 

- 服务器在第一次握手消息之后立即发送虚拟change_cipher_spec记录。 这可能是在ServerHello或HelloRetryRequest之后。 

当放在一起时，这些更改使TLS 1.3握手类似于TLS 1.2会话恢复，这提高了通过中间盒成功连接的机会。 这种“兼容模式”是部分协商的：客户端可以选择是否提供会话ID，服务器必须回应它。 任何一方都可以在握手期间随时发送change_cipher_spec，因为它们必须被对等方忽略，但如果客户端发送非空会话ID，则服务器必须按照本附录中的描述发送change_cipher_spec。 


 Rescorla Standards Track [第140页] 
 
 RFC 8446 TLS 2018年8月



 D.5 。  与向后兼容性相关的安全限制

协商使用旧版TLS的实现应该更倾向于使用前向密钥和AEAD密码套件（如果可用）。 

由于[RFC7465]中引用的原因，RC4密码套件的安全性被认为是不够的。 实现不得出于任何原因为任何版本的TLS提供或协商RC4密码套件。 

旧版本的TLS允许使用非常低强度的密码。 由于任何原因，任何版本的TLS都不得提供或协商强度低于112位的密码。 

由于[RFC7568]中列举的原因，SSL 3.0 [RFC6101]的安全性被认为是不够的，并且不得出于任何原因进行协商。 

由于[RFC6176]中列举的原因，SSL 2.0 [SSL2]的安全性被认为是不够的，并且不得出于任何原因进行协商。 

实现绝不能发送兼容SSL 2.0的CLIENT-HELLO。 实现不得使用兼容SSL 2.0的CLIENT-HELLO协商TLS 1.3或更高版本。 不推荐实现接受兼容SSL版本2.0的CLIENT-HELLO以协商旧版本的TLS。 

实现绝不能将ClientHello.legacy_version或ServerHello.legacy_version设置为0x0300或更低。 任何端点接收Hello消息，ClientHello.legacy_version或ServerHello.legacy_version设置为0x0300必须使用“protocol_version”警报中止握手。 

实现绝不能发送版本低于0x0300的任何记录。 实现不应该接受版本低于0x0300的任何记录（但如果完全忽略记录版本号，可能会无意中这样做）。 

实现绝不能使用[RFC6066]第7节中定义的Truncated HMAC扩展，因为它不适用于AEAD算法，并且在某些情况下已被证明是不安全的。 




 Rescorla Standards Track [第141页] 
 
 RFC 8446 TLS 2018年8月


 附录E.  安全属性概述

对TLS的完整安全性分析超出了本文档的范围。 在本附录中，我们提供了对所需属性的非正式描述，以及对提供更正式定义的研究文献中更详细工作的参考。 

我们将握手的属性与记录层的属性分开。 
 E.1 。  握手

TLS握手是经过身份验证的密钥交换（AKE）协议，旨在提供单向身份验证（仅服务器）和相互身份验证（客户端和服务器）功能。 在握手完成时，每一侧都输出以下值的视图： 

- 一组“会话密钥”（从主密钥导出的各种秘密），可以从中导出一组工作密钥。 

- 一组加密参数（算法等）。 

- 通信方的身份。 

我们假设攻击者是一个活跃的网络攻击者，这意味着它可以完全控制用于双方之间通信的网络[RFC3552] 。 即使在这些条件下，握手也应提供下面列出的属性。 请注意，这些属性不一定是独立的，而是反映了协议消费者的需求。 

建立相同的会话密钥：握手需要在握手的两侧输出相同的会话密钥集，前提是它在每个端点上成功完成（参见[CK01] ，定义1，第1部分）。 

会话密钥的保密性：应该知道共享会话密钥 
仅限于通信方而不是攻击者（参见[CK01] ，定义1，第2部分）。 请注意，在单方面验证的连接中，攻击者可以与服务器建立自己的会话密钥，但这些会话密钥与客户端建立的会话密钥不同。 

对等身份验证：客户端对等身份的视图应该是 
反映服务器的身份。 如果客户端已通过身份验证，则服务器的对等身份视图应与客户端的身份相匹配。 


 Rescorla Standards Track [第142页] 
 
 RFC 8446 TLS 2018年8月


会话密钥的唯一性：任何两个不同的握手应该 
产生不同的，不相关的会话密钥。 握手产生的单个会话密钥也应该是独立且独立的。 

降级保护：加密参数应该是 
双方都是一样的，如同同伴在没有攻击的情况下进行通信一样（参见[BBFGKZ16] ，定义8和9）。 

关于长期密钥的前瞻性：如果是长期的 
密钥材料（在这种情况下，基于证书的身份验证模式中的签名密钥或PSK中带有（EC）DHE模式的外部/恢复PSK）在握手完成后受到损害，这不会损害会话密钥的安全性（请参阅[DOW92] ），只要会话密钥本身已被删除。 当在“psk_ke”PskKeyExchangeMode中使用PSK时，不满足前向保密属性。

关键妥协假冒（KCI）抵抗：相互影响 
与证书进行身份验证连接，损害一个参与者的长期秘密不应该破坏该参与者在给定连接中对其对等体的身份验证（参见[HGFS15] ）。 例如，如果客户端的签名密钥被泄露，则不应该在随后的握手中模拟该客户端的任意服务器。 

端点身份的保护：服务器的身份 
（证书）应该被保护免受被动攻击者的攻击。 应该保护客户端的身份免受被动和主动攻击者的攻击。 

非正式地，TLS 1.3的基于签名的模式提供了由（EC）DHE密钥交换建立的唯一的，秘密的共享密钥，并且通过握手记录通过服务器的签名进行认证，并且与服务器的身份相关联。通过MAC。 如果客户端通过证书进行身份验证，它还会签署握手记录并提供与这两个身份相关联的MAC。 [SIGMA]描述了这种密钥交换协议的设计和分析。 如果每个连接使用新的（EC）DHE密钥，则输出密钥是前向保密的。 

外部PSK和恢复PSK从长期共享密钥引导到一组唯一的每个连接短期会话密钥。 这个秘密可能是在之前的握手中建立的。 如果使用具有（EC）DHE密钥建立的PSK，则这些会话密钥也将是前向保密的。 已经设计了恢复PSK，使得由连接N计算并且形成连接N + 1所需的恢复主秘密与连接N使用的业务密钥分开，从而在连接之间提供前向保密。 此外，如果在同一连接上建立了多个票证，则它们与不同的密钥相关联，因此与一个票证相关联的PSK的泄密不会导致与与其他票证相关联的PSK建立的连接的危害。 如果票证存储在数据库中（因此可以删除）而不是它们是自加密的，则此属性最有趣。 


 Rescorla Standards Track [第143页] 
 
 RFC 8446 TLS 2018年8月



PSK绑定器值形成PSK与当前握手之间的绑定，以及在建立PSK的会话与当前会话之间的绑定。 这种结合传递性地包括原始握手记录，因为该记录被消化成产生恢复主秘密的值。 这要求用于产生恢复主密钥的KDF和用于计算绑定器的MAC都是抗冲突的。 有关详细信息，请参阅附录E.1.1 。 注意：活页夹不包括其他PSK的活页夹值，但它们包含在已完成的MAC中。 

TLS当前不允许服务器在非基于证书的握手（例如，PSK）中发送certificate_request消息。 如果将来放宽此限制，客户的签名将不会直接覆盖服务器的证书。 但是，如果PSK是通过NewSessionTicket建立的，则客户端的签名将通过PSK活页夹传递地覆盖服务器的证书。 [PSK-FINISHED]描述了对未绑定到服务器证书的结构的具体攻击（另请参阅[Kraw16] ）。 当客户端可能与两个不同的端点共享相同的PSK /密钥ID对时，使用基于证书的客户端身份验证是不安全的。 实现绝不能将外部PSK与客户端或服务器的基于证书的身份验证相结合，除非通过某些扩展协商。 

如果使用导出器，则它会生成唯一且保密的值（因为它们是从唯一的会话密钥生成的）。 使用不同标签和上下文计算的导出器在计算上是独立的，因此从导出值计算彼此或会话机密是不可行的。 注意：出口商可以生成任意长度的值; 如果要将导出器用作通道绑定，则导出的值必须足够大以提供抗冲突性。 TLS 1.3中提供的导出器分别来自与早期流量密钥和应用程序流量密钥相同的握手上下文，因此具有类似的安全属性。 请注意，它们不包括客户的证书; 希望绑定到客户端证书的未来应用程序可能需要定义包含完整握手记录的新导出器。 对于所有握手模式，完成的MAC（以及存在的签名）可防止降级攻击。 此外，如第4.1.3节所述，在随机随机数中使用某些字节可以检测降级到以前的TLS版本。 有关TLS 1.3和降级的更多详细信息，请参阅[BBFGKZ16] 。 


 Rescorla Standards Track [第144页] 
 
 RFC 8446 TLS 2018年8月



一旦客户端和服务器交换了足够的信息来建立共享密钥，握手的其余部分就会被加密，从而提供针对被动攻击者的保护，即使计算的共享密钥未经过身份验证。 由于服务器在客户端之前进行身份验证，因此客户端可以确保如果服务器对服务器进行身份验证，则只会向经过身份验证的服务器显示其身份。 请注意，实现必须在握手期间使用提供的记录填充机制，以避免由于长度而泄露有关身份的信息。 客户端提议的PSK标识未加密，也不是服务器选择的标识。 
 E.1.1 。  主要推导和HKDF

TLS 1.3中的密钥派生使用[RFC5869]中定义的HKDF及其两个组成部分HKDF -Extract和HKDF-Expand。 HKDF建设的全部理由可以在[Kraw10]中找到，以及在[KW16]中用于TLS 1.3的方式的基本原理。 在本文件中，HKDF-Extract的每次申请都会进行一次或多次HKDF-Expand的调用。 应始终遵循此顺序（包括在本文档的未来修订版中）; 特别是，我们不应使用HKDF-Extract的输出作为HKDF-Extract的另一个应用程序的输入，而不需要HKDF-Expand。 只要通过密钥和/或标签区分这些输入，就允许HKDF-Expand多次应用于某些相同的输入。 

请注意，HKDF-Expand实现了具有可变长度的输入和输出的伪随机函数（PRF）。 在本文件中HKDF的一些用途（例如，用于生成出口商和resumption_master_secret），HKDF-Expand的应用必须具有抗冲突性; 也就是说，找到输出相同值的HKDF-Expand的两个不同输入是不可行的。 这要求底层散列函数具有抗冲突性，并且HKDF-Expand的输出长度至少为256位（或者是散列函数所需的，以防止发现冲突）。
 Rescorla Standards Track [第145页] 
 
 RFC 8446 TLS 2018年8月
 E.1.2 。  客户认证

在握手期间或握手后身份验证期间已将身份验证数据发送到服务器的客户端无法确定服务器之后是否认为客户端已经过身份验证。 如果客户端需要确定服务器是否认为连接是单方面的或相互认证的，则必须由应用层提供。 有关详细信息，请参见[CHHSV17] 。 另外，来自[Kraw16]的握手后认证分析表明，在握手后阶段发送的证书所识别的客户端拥有流量密钥。 因此，该方是参与原始握手的客户或原始客户委托交通密钥的客户（假设交通密钥未被泄露）。 
 E.1.3 。  0-RTT

0-RTT操作模式通常提供类似于1-RTT数据的安全属性，但有两个例外，即0-RTT加密密钥不提供完全的前向保密，并且服务器无法保证握手的唯一性（不可重复性），不保留可能过多的状态。 有关限制重放曝光的机制，请参阅第8节 。 
 E.1.4 。  出口商独立

exporter_master_secret和early_exporter_master_secret的派生独立于流量密钥，因此不会对使用这些密钥加密的流量的安全性构成威胁。 但是，因为这些秘密可以用来计算任何出口商价值，所以它们应该尽快删除。 如果已知导出器标签的总集合，则实现应该为所有这些标签预先计算导出器计算的内部Derive-Secret阶段，然后擦除[early_] exporter_master_secret，然后在知道每个内部值后立即执行它将不再需要它。 
 E.1.5 。  妥协后安全

TLS不提供在对等方的长期秘密（签名密钥或外部PSK）受损后发生的握手的安全性。 因此，它不提供妥协后安全性[CCG16] ，有时也称为后向或未来保密。 这与KCI抵抗相反，KCI抵抗描述了一方在其自身的长期秘密受到损害后所拥有的安全保障。 



 Rescorla Standards Track [第146页] 
 
 RFC 8446 TLS 2018年8月


 E.1.6 。  外部参考

读者应参考以下参考文献来分析TLS握手： [DFGS15] ， [CHSV16] ， [DFGS16] ， [KW16] ， [Kraw16] ， [FGSW16] ， [LXZFH16] ， [FG17]和[BBK17 ] ] 。 
 E.2 。  记录层

记录层依赖于握手产生强大的流量机密，可用于导出双向加密密钥和随机数。 假设这是真的，并且密钥不再用于第5.5节中指示的数据，那么记录层应该提供以下保证： 

机密性：攻击者无法确定 
给定记录的明文内容。 

完整性：攻击者不应该制作新记录 
这与接收方将接受的现有记录不同。 

订单保护/不可重放性：攻击者不应该 
使接收者接受它已经接受的记录或使接收者接受记录N + 1而没有先处理记录N. 

长度隐藏：给定具有给定外部长度的记录， 
攻击者不应该能够确定内容与填充的记录量。 

密钥更改后转发保密：如果流量密钥更新 
已使用第4.6.3节中描述的机制并删除上一代密钥，攻击端点的攻击者不应解密使用旧密钥加密的流量。 

非正式地，TLS 1.3通过AEAD提供这些属性 - 用强密钥保护明文。 AEAD加密[RFC5116]为数据提供机密性和完整性。 通过对每个记录使用单独的随机数来提供不可重放性，其中随机数来自记录序列号（ 第5.3节 ），序列号在两侧独立维护; 因此，无序传送的记录导致AEAD去保护失败。 为了防止大量密码分析在不同用户在相同密钥下重复加密相同的明文时（通常是HTTP的情况），通过将序列号与从中导出的秘密每连接初始化向量混合来形成随机数。交通钥匙。 有关此结构的分析，请参见[BT16] 。 




 Rescorla Standards Track [第147页] 
 
 RFC 8446 TLS 2018年8月



TLS 1.3中的密钥更新技术（参见第7.2节 ）遵循[REKEY]中讨论的串行生成器的构造，它表明重新加密可以允许密钥用于大量加密，而不是重新加密。 这依赖于HKDF-Expand-Label函数作为伪随机函数（PRF）的安全性。 此外，只要此功能是真正的一种方式，就不可能在密钥更改（前向保密）之前计算流量密钥。 

TLS不为在该连接的流量密钥泄露后在连接上传送的数据提供安全性。 也就是说，TLS不提供关于交通秘密的妥协后安全/未来保密/后向保密。 实际上，了解交通秘密的攻击者可以计算该连接上的所有未来交通密钥。 需要此类保证的系统需要进行新的握手并与（EC）DHE交换建立新连接。 
 E.2.1 。  外部参考

读者应参考以下参考文献来分析TLS记录层： [BMMRT15] ， [BT16] ， [BDFKPPRSZZ16] ， [BBK17]和[PS18] 。 
 E.3 。  流量分析

基于观察加密数据包的长度和时间，TLS容易受到各种流量分析攻击[CLINIC] [HCJC16] 。 当存在一小组可能的消息要区分时，这是特别容易的，例如对于托管固定内容集的视频服务器，但是即使在更复杂的场景中仍然提供可用信息。 

TLS不提供针对此类攻击的任何特定防御，但包括供应用程序使用的填充机制：受AEAD功能保护的明文由内容和可变长度填充组成，允许应用程序生成任意长度的加密记录以及仅填充覆盖流量以隐藏传输周期和静默期之间的差异。 由于填充与实际内容一起加密，攻击者无法直接确定填充的长度，但可以通过使用在记录处理期间暴露的定时通道间接测量填充（即，查看处理记录所需的时间长度或者在记录中涓涓细流，看看哪些引起服务器的响应）。 通常，不知道如何删除所有这些通道，因为即使是恒定时间填充删除功能也可能将内容提供给依赖于数据的功能。 至少，完全恒定时间的服务器或客户端需要与应用层协议实现密切合作，包括使更高级别的协议保持恒定时间。 


 Rescorla Standards Track [第148页] 
 
 RFC 8446 TLS 2018年8月



注意：由于传输数据包的延迟和流量增加，强大的流量分析防御可能会导致性能下降。 
 E.4 。  侧通道攻击

通常，TLS没有针对旁道攻击的特定防御（即，通过诸如定时之类的辅助信道攻击通信的那些），而是将这些攻击留给相关加密原语的实现。 但是，TLS的某些功能旨在使编写侧通道阻抗代码更容易： 

- 与使用复合MAC-then-encrypt结构的先前版本的TLS不同，TLS 1.3仅使用AEAD算法，允许实现使用这些原语的自包含常量时间实现。 

- TLS对所有解密错误使用统一的“bad_record_mac”警报，旨在防止攻击者获得对消息部分的分段洞察。 通过终止这种错误的连接来提供额外的阻力; 新连接将具有不同的加密材料，从而防止对需要多次试验的加密原语进行攻击。 

通过辅助信道的信息泄漏可以发生在TLS以上的层，应用协议和使用它们的应用中。 对侧信道攻击的抵抗力取决于应用程序和应用程序协议，分别确保机密信息不会被无意泄露。
 Rescorla Standards Track [第149页] 
 
 RFC 8446 TLS 2018年8月
 E.5 。  重播0-RTT上的攻击

可重复使用的0-RTT数据对使用TLS的应用程序提出了许多安全威胁，除非这些应用程序经过专门设计以便在重放时安全（最低限度，这意味着幂等，但在许多情况下可能还需要其他更强的条件，例如常数 - 时间反应）。 潜在的攻击包括： 

- 重复导致副作用（例如，购买物品或转移资金）的动作被复制，从而损害网站或用户。 

- 攻击者可以存储和重放0-RTT消息，以便针对其他消息对其进行重新排序（例如，在创建之后将删除移动到）。 

- 利用缓存计时行为，通过将0-RTT消息重播到不同的缓存节点，然后使用单独的连接来测量请求延迟来查找0-RTT消息的内容，以查看这两个请求是否寻址相同的资源。 

如果可以多次重放数据，则可能发生其他攻击，例如重复测量加密操作的速度。 此外，他们可能能够限制速率限制系统。 有关这些攻击的进一步说明，请参阅[Mac17] 。 

最终，服务器有责任保护自己免受使用0-RTT数据复制的攻击。 第8节中描述的机制旨在防止在TLS层重放，但不提供完全保护以防止接收客户端数据的多个副本。 当服务器没有关于客户端的任何信息时，TLS 1.3回退到1-RTT握手，例如，因为它位于不共享状态的不同集群中，或者因为票证已被删除，如第8.1节所述。 如果应用层协议在此设置中重新传输数据，则攻击者可能通过将ClientHello发送到原始群集（立即处理数据）和另一个将回退到1-RTT的群集来引发消息重复在应用层重放时处理数据。 此攻击的规模受到客户重试事务的意愿的限制，因此只允许有限量的重复，每个副本在服务器上显示为新连接。 如果正确实现，第8.1和8.2节中描述的机制可防止重放的ClientHello及其相关的0-RTT数据被具有一致状态的任何集群多次接受; 对于将0-RTT的使用限制为单个票证的一个集群的服务器，则给定的ClientHello及其关联的0-RTT数据将仅被接受一次。 但是，如果状态不完全一致，则攻击者可能能够在复制窗口期间接受多个数据副本。 由于客户端不知道服务器行为的确切细节，因此它们不得在早期数据中发送消息，这些消息不安全重放，并且他们不愿意在多个1-RTT连接中重试。
 Rescorla Standards Track [第150页] 
 
 RFC 8446 TLS 2018年8月

如果没有定义其用途的配置文件，应用程序协议绝不能使用0-RTT数据。 该配置文件需要识别哪些消息或交互可以安全地与0-RTT一起使用，以及如何在服务器拒绝0-RTT并回退到1-RTT时处理这种情况。 

此外，为了避免意外误用，除非应用程序特别要求，否则TLS实现不得启用0-RTT（发​​送或接受），除非服务器拒绝，否则不得自动重新发送0-RTT数据，除非应用程序指示。 服务器端应用程序可能希望对某些类型的应用程序流量实现0-RTT数据的特殊处理（例如，中止连接，请求在应用程序层重新发送数据，或延迟处理直到握手完成）。 为了允许应用程序实现这种处理，TLS实现必须为应用程序提供一种确定握手是否已完成的方法。 
 E.5.1 。  重播和出口商

ClientHello的重播产生了相同的早期出口商，因此需要使用这些出口商的应用程序进行额外的关注。 特别是，如果将这些导出器用作身份验证通道绑定（例如，通过对导出器的输出进行签名），则危害PSK的攻击者可以在连接之间移植身份验证器而不会损害身份验证密钥。 

此外，早期的导出器不应该用于生成服务器到客户端的加密密钥，因为这需要重用这些密钥。 这与仅在客户端到服务器方向上使用早期应用程序流量密钥相似。
 Rescorla Standards Track [第151页] 
 
 RFC 8446 TLS 2018年8月
 E.6 。  PSK身份曝光

由于实现通过中止握手来响应无效的PSK绑定器，因此攻击者可能验证给定的PSK身份是否有效。 具体来说，如果服务器同时接受外部PSK握手和基于证书的握手，则有效的PSK身份将导致握手失败，而只会跳过无效身份并导致证书握手成功。 单独支持PSK握手的服务器可以通过处理没有有效PSK身份的情况以及存在身份但具有相同无效绑定的情况来抵抗这种形式的攻击。 
 E.7 。  分享PSK

TLS 1.3通过将PSK绑定到特定的KDF来对PSK采取保守的方法。 相比之下，TLS 1.2允许PSK与任何散列函数和TLS 1.2 PRF一起使用。 因此，与TLS 1.2和TLS 1.3一起使用的任何PSK必须仅与TLS 1.3中的一个散列一起使用，如果用户想要提供单个PSK，则该散列不是最佳的。 TLS 1.2和TLS 1.3中的结构是不同的，尽管它们都基于HMAC。 虽然没有已知的方法可以在两个版本中相同的PSK产生相关输出，但只进行了有限的分析。 通过不在TLS 1.3和TLS 1.2之间重用PSK，实现可以确保跨协议相关输出的安全性。 
 E.8 。  攻击静态RSA

虽然TLS 1.3不使用RSA密钥传输，因此不会直接受到Bleichenbacher类型攻击[Blei98] ，如果TLS 1.3服务器在以前版本的TLS环境中也支持静态RSA，那么可以冒充服务器对于TLS 1.3连接[JSS15] 。 TLS 1.3实现可以通过在所有版本的TLS上禁用对静态RSA的支持来防止此类攻击。 原则上，实现也可能能够将具有不同keyUsage位的证书分开以用于静态RSA解密和RSA签名，但是该技术依赖于客户端拒绝使用没有设置digitalSignature位的证书中的密钥来接受签名，并且许多客户端执行此操作不执行此限制。
 Rescorla Standards Track [第152页] 
 
 RFC 8446 TLS 2018年8月
贡献者 

Martin Abadi加州大学圣克鲁兹分校abadi@cs.ucsc.edu 

Christopher Allen（TLS 1.0的共同编辑）Alacrity Ventures ChristopherA@AlacrityManagement.com 

Richard Barnes Cisco rlb@ipv.sx 

Steven M. Bellovin哥伦比亚大学smb@cs.columbia.edu 

David Benjamin Google davidben@google.com 

Benjamin Beurdouche INRIA和Microsoft Research benjamin.beurdouche@ens.fr 

Karthikeyan Bhargavan（ [RFC7627]编辑）INRIA karthikeyan.bhargavan@inria.fr 

Simon Blake-Wilson（ [RFC4492]的合着者）BCI sblakewilson@bcisse.com 

Nelson Bolyard（ [RFC4492]的合着者）Sun Microsystems，Inc。nelson@bolyard.com 

Ran Canetti IBM canetti@watson.ibm.com Matt Caswell OpenSSL matt@openssl.org
 Rescorla Standards Track [第153页] 
 
 RFC 8446 TLS 2018年8月

斯蒂芬Checkoway伊利诺伊大学芝加哥分校sfc@uic.edu 

Pete Chown Skygate Technology Ltd pc@skygate.co.uk 

Katriel Cohn-Gordon牛津大学me@katriel.co.uk 

Cas Cremers牛津大学cas.cremers@cs.ox.ac.uk 

Antoine Delignat-Lavaud（ [RFC7627]的合着者）INRIA antdl@microsoft.com 

Tim Dierks（TLS 1.0的共同作者，TLS 1.1和1.2的共同编辑）独立的tim@dierks.org 

Roelof DuToit赛门铁克公司roelof_dutoit@symantec.com 

Taher Elgamal Securify taher@s​​ecurify.com 

Pasi Eronen诺基亚pasi.eronen@nokia.com 

Cedric Fournet Microsoft fournet@microsoft.com Anil Gangolli anil@busybuddha.org
 Rescorla Standards Track [第154页] 
 
 RFC 8446 TLS 2018年8月

David M. Garrett dave@nulldereference.com 

Illya Gerasymchuk独立illya@iluxonchik.me 

Alessandro Ghedini Cloudflare Inc. alessandro@cloudflare.com 

Daniel Kahn Gillmor ACLU dkg@fifthhorseman.net 

Matthew Green Johns Hopkins University mgreen@cs.jhu.edu 

Jens Guballa ETAS jens.guballa@etas.com 

Felix Guenther TU Darmstadt mail@felixguenther.info 

Vipul Gupta（ [RFC4492]的合着者）Sun Microsystems Laboratories vipul.gupta@sun.com 

Chris Hawk（ [RFC4492]的合着者）Corriente Networks LLC chris@corriente.net 

基普希克曼 

阿尔弗雷德霍恩斯 

David Hopwood独立顾问david.hopwood@blueyonder.co.uk Marko Horvat MPI-SWS mhorvat@mpi-sws.org 



 Rescorla Standards Track [第155页] 
 
 RFC 8446 TLS 2018年8月



伦敦大学Jonathan Hoyland皇家霍洛威jonathan.hoyland@gmail.com 

Subodh Iyengar Facebook subodh@fb.com 

Benjamin Kaduk Akamai Technologies kaduk@mit.edu 

Hubert Kario Red Hat Inc. hkario@redhat.com 

Phil Karlton（SSL 3.0的合着者） 

Leon Klingele独立邮件：mail@leonklingele.de 

Paul Kocher（SSL 3.0的合着者）Cryptography Research paul@cryptography.com 

Hugo Krawczyk IBM hugokraw@us.ibm.com 

Adam Langley（ [RFC7627]的合着者）Google agl@google.com 

Olivier Levillain ANSSI olivier.levillain@ssi.gouv.fr Xiaoyin Liu北卡罗来纳大学教堂山分校xiaoyin.l@outlook.com
 Rescorla Standards Track [第156页] 
 
 RFC 8446 TLS 2018年8月

Ilari Liusvaara独立ilariliusvaara@welho.com 

Atul Luykx KU Leuven atul.luykx@kuleuven.be 

Colm MacCarthaigh亚马逊网络服务colm@allcosts.net 

Carl Mehner USAA carl.mehner@usaa.com 

Jan Mikkelsen Transactionware janm@transactionware.com 

Bodo Moeller（ [RFC4492]的合着者）Google bodo@acm.org 

Kyle Nekritz Facebook knekritz@fb.com 

Erik Nygren Akamai Technologies erik+ietf@nygren.org 

Magnus Nystrom Microsoft mnystrom@microsoft.com 

Kazuho Oku DeNA Co.，Ltd。kazuhooku@gmail.com伦敦大学Kenny Paterson Royal Holloway，电子邮件：kenny.paterson@rhul.ac.uk
 Rescorla Standards Track [第157页] 
 
 RFC 8446 TLS 2018年8月

克里斯托弗巴顿佛罗里达大学cjpatton@ufl.edu 

Alfredo Pironti（ [RFC7627]的合着者）INRIA alfredo.pironti@inria.fr 

Andrei Popov Microsoft andrei.popov@microsoft.com 

Marsh Ray（ [RFC7627]的合着者）Microsoft maray@microsoft.com 

Robert Relyea Netscape Communications依赖于@netscape.com 

Kyle Rose Akamai Technologies krose@krose.org 

Jim Roskind亚马逊jroskind@amazon.com 

迈克尔萨宾 

Joe Salowey Tableau Software joe@salowey.net 

Rich Salz Akamai rsalz@akamai.com 

David Schinazi Apple Inc. dschinazi@apple.com Sam Scott Royal Holloway，伦敦大学me@samjs.co.uk 



 Rescorla Standards Track [第158页] 
 
 RFC 8446 TLS 2018年8月



Thomas Shrimpton佛罗里达大学teshrim@ufl.edu 

Dan Simon Microsoft，Inc。dansimon@microsoft.com 

Brian Smith独立brian@briansmith.org 

Brian Sniffen Akamai Technologies ietf@bts.evenmere.org 

Nick Sullivan Cloudflare Inc. nick@cloudflare.com 

Bjoern Tackmann加州大学圣地亚哥分校btackmann@eng.ucsd.edu 

Tim Taubert Mozilla ttaubert@mozilla.com 

Martin Thomson Mozilla mt@mozilla.com 

Hannes Tschofenig Arm Limited Hannes.Tschofenig@arm.com 

肖恩特纳sn3rd sean@sn3rd.com 

Steven Valdez Google svaldez@google.com Filippo Valsorda Cloudflare Inc. filippo@cloudflare.com 



 Rescorla Standards Track [第159页] 
 
 RFC 8446 TLS 2018年8月



Thyla van der Merwe Royal Holloway，伦敦大学tjvdmerwe@gmail.com 

Victor Vasiliev Google vasilvv@google.com 

Hoeteck Wee Ecole Normale Superieure，Paris hoeteck@alum.mit.edu 

汤姆温斯坦 

David Wong NCC Group david.wong@nccgroup.trust 

Christopher A. Wood Apple Inc. cawood@apple.com 

蒂姆赖特沃达丰timothy.wright@vodafone.com 

Peter Wu独立peter@lekensteyn.nl 

Kazu Yamamoto Internet Initiative Japan Inc. kazu@iij.ad.jp 

作者的地址 

Eric Rescorla Mozilla 

电子邮件：ekr@rtfm.com 







Rescorla Standards Track [第160页] 


     由rfcmarkup 1.129b生成的Html标记，可从 
 
https://tools.ietf.org/tools/rfcmarkup/ 




将文件翻译成日本语，svenska，Nederlands，Deutsch，français，русский，italiano，español，TiếngViệt，polski，português，中文，українська，català，norsk，فارسی，suomi，Bahasa Indonesia，العربية，čeština，한국어，Bahasa Melayu ，magyar，română，српски和其他语言。